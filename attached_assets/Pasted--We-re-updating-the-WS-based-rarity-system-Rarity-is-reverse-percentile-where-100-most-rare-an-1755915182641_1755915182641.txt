
We’re updating the WS-based rarity system:
	•	Rarity is reverse percentile where 100 = most rare and 0 = most common.
	•	The rarity chip color must be red → yellow → green as score increases.
	•	Under the grid, the Rarity summary must not say “lower = better”; it should treat higher = better.
	•	The Player modal needs a new Rarity section (above Teams) showing “Rarity 73 • Rank 12 of 284 eligible” and a one-line blurb (e.g., “Rare pick”).
	•	Rename “Other Top Answers” → “Other Answers” and list all eligible players by WS rank (DESC). The chosen player should appear in that list at their actual WS rank.

1) Update the rarity computation (flip to 100 = most rare)

Edit src/utils/rarityWS.ts (or create if it doesn’t exist). Replace these functions as shown:

// src/utils/rarityWS.ts
export type LeaguePlayer = any;

/** Regular-season career Win Shares = sum(ows + dws) */
export function careerWS_RS(player: LeaguePlayer): number {
  const stats = (player.stats ?? []).filter((s: any) => !s?.playoffs);
  let ows = 0, dws = 0;
  for (const s of stats) {
    ows += Number(s?.ows ?? 0);
    dws += Number(s?.dws ?? 0);
  }
  const ws = ows + dws;
  return Number.isFinite(ws) ? ws : 0;
}

/**
 * Compute rarity maps per cell using WS.
 * Sort DESC by WS (highest first = most common).
 * Now rarity = reverse percentile (100 = most rare, 0 = most common)
 *   idx = 0..N-1 (0 = highest WS)
 *   rarity = round(100 * (1 - idx / (N - 1)))
 */
export function computeCellRarityByWS(eligiblePlayers: LeaguePlayer[]) {
  const arr = eligiblePlayers.map(p => ({ pid: p.pid, ws: careerWS_RS(p), player: p }));
  arr.sort((a, b) => (b.ws - a.ws) || (a.pid - b.pid)); // DESC WS, stable

  const N = arr.length;
  const rarityMap = new Map<number, number>();
  const rankMap = new Map<number, number>();
  const wsMap = new Map<number, number>();

  if (N === 0) return { rarityMap, rankMap, wsMap, eligibleCount: 0, ordered: [] };
  if (N === 1) {
    const only = arr[0];
    rarityMap.set(only.pid, 50);
    rankMap.set(only.pid, 1);
    wsMap.set(only.pid, only.ws);
    return { rarityMap, rankMap, wsMap, eligibleCount: 1, ordered: arr };
  }

  arr.forEach((row, idx) => {
    const rarity = Math.round(100 * (1 - idx / (N - 1))); // 100..0
    rarityMap.set(row.pid, rarity);
    rankMap.set(row.pid, idx + 1);
    wsMap.set(row.pid, row.ws);
  });

  return { rarityMap, rankMap, wsMap, eligibleCount: N, ordered: arr };
}

/** Chip color: 0 = red, 50 = amber, 100 = green */
export function rarityColor(score: number) {
  // Map 0..100 → hue 0..120 (red → green)
  const clamp = (n: number, a: number, b: number) => Math.max(a, Math.min(b, n));
  const hue = clamp((score / 100) * 120, 0, 120);
  return `hsl(${hue}deg 80% 45%)`;
}

export function rarityLabel(score: number): "Common"|"Uncommon"|"Notable"|"Rare"|"Ultra-rare" {
  if (score >= 80) return "Ultra-rare";
  if (score >= 60) return "Rare";
  if (score >= 40) return "Notable";
  if (score >= 20) return "Uncommon";
  return "Common";
}

2) Where we compute per-cell rarity, make sure we return the sorted eligible list

Edit src/logic/cellRarityByWS.ts (or create):

// src/logic/cellRarityByWS.ts
import { computeCellRarityByWS } from "../utils/rarityWS";

const cache = new Map<string, any>();

export function buildCellRarityMaps(cellKey: string, eligiblePlayers: any[]) {
  if (cache.has(cellKey)) return cache.get(cellKey);
  const maps = computeCellRarityByWS(eligiblePlayers);
  cache.set(cellKey, maps);
  return maps;
}

export function resetCellRarity(cellKey: string) {
  cache.delete(cellKey);
}

Make sure your guess handler already calls buildCellRarityMaps(cellKey, eligiblePlayers) and stores:
	•	rarity, rarityRank, eligibleCount, careerWS for the chosen player
	•	Keep ordered as the full list (to render “Other Answers”)

3) Reverse chip colors and text on tiles

In the grid cell component (where we render a correct guess chip), update:

// GridCell.tsx
import { rarityColor, rarityLabel } from "../utils/rarityWS";

{isCorrect && typeof rarity === "number" && (
  <div
    className="rarity-chip"
    title={`Rarity ${rarity} (${rarityLabel(rarity)}) • Rank ${rarityRank} of ${eligibleCount}`}
    style={{
      position: "absolute",
      right: 8, bottom: 8,
      padding: "2px 8px",
      borderRadius: 999,
      fontSize: 12,
      fontWeight: 700,
      background: rarityColor(rarity), // 0 red → 100 green
      color: "black",
      boxShadow: "0 0 0 2px rgba(0,0,0,.35)",
    }}
  >
    {rarity}
  </div>
)}

(We still keep the tile background green/red for correctness; only the chip color changes.)

4) Update the summary under the grid (higher = better)

Edit the component under the grid (e.g., RaritySummaryUnderGrid.tsx):
	•	Remove any “lower = better” copy.
	•	Treat higher = better for “Best Pick”.
	•	Compute totals/average over correct picks.

// RaritySummaryUnderGrid.tsx
type Sample = { cellKey: string; pid: number; rarity: number; correct: boolean };

export default function RaritySummaryUnderGrid({ samples }: { samples: Sample[] }) {
  const vals = samples.filter(s => s.correct && Number.isFinite(s.rarity)).map(s => s.rarity);
  const total = vals.reduce((a,b)=>a+b, 0);
  const avg = vals.length ? Math.round((total/vals.length)*10)/10 : 0;
  const best = vals.length ? Math.max(...vals) : 0;   // now best = HIGHEST
  const mostCommon = vals.length ? Math.min(...vals) : 0;

  return (
    <div style={{
      marginTop: 12,
      padding: 12,
      borderRadius: 12,
      background: "rgba(255,255,255,0.05)",
      display: "grid",
      gridTemplateColumns: "1fr 1fr 1fr 1fr",
      gap: 8
    }}>
      <Stat label="Rarity Score (total)" value={total} />
      <Stat label="Average" value={avg} />
      <Stat label="Best pick" value={best} hint="highest rarity" />
      <Stat label="Most common" value={mostCommon} hint="lowest rarity" />
    </div>
  );
}

function Stat({ label, value, hint }:{label:string; value:number|string; hint?:string}) {
  return (
    <div>
      <div style={{opacity:.7, fontSize:12}}>{label}</div>
      <div style={{fontWeight:800, fontSize:18}}>{value}</div>
      {hint ? <div style={{opacity:.55, fontSize:11}}>{hint}</div> : null}
    </div>
  );
}

5) Player modal changes

a) New “Rarity” section above “Teams”
	•	Show: Rarity 73
	•	Subtext: Rank 12 of 284 eligible
	•	One-liner: label from rarityLabel(score) (e.g., “Rare pick”)

// In PlayerProfileModal.tsx (where you render the modal content)
import { rarityLabel } from "../utils/rarityWS";

function RaritySection({ rarity, rarityRank, eligibleCount }:{
  rarity?: number; rarityRank?: number; eligibleCount?: number;
}) {
  if (!Number.isFinite(rarity) || !rarityRank || !eligibleCount) return null;
  return (
    <div className="stat-card" style={{background:"rgba(255,255,255,0.06)", borderRadius:14, padding:12, marginBottom:12}}>
      <div style={{fontWeight:700, marginBottom:6}}>Rarity</div>
      <div style={{fontSize:28, fontWeight:800}}>{Math.round(rarity as number)}</div>
      <div style={{opacity:.8, marginTop:4}}>
        Rank {rarityRank} of {eligibleCount} eligible • {rarityLabel(rarity as number)}
      </div>
    </div>
  );
}

Render <RaritySection ... /> before the Teams card, using the values stored on the cell guess.

b) Rename and populate “Other Answers”
Show every eligible player in WS rank order (DESC). Use the ordered array from buildCellRarityMaps. Include the chosen player at their exact spot (it will appear naturally if you render the full list). Optionally bold the chosen row.

// Still in PlayerProfileModal.tsx
function OtherAnswersList({ ordered, chosenPid }:{ ordered: Array<{pid:number; ws:number; player:any}>, chosenPid?: number }) {
  if (!ordered?.length) return null;
  return (
    <div className="stat-card" style={{background:"rgba(255,255,255,0.06)", borderRadius:14, padding:12, marginTop:12}}>
      <div style={{fontWeight:700, marginBottom:6}}>Other Answers</div>
      <ol style={{maxHeight:240, overflowY:"auto", paddingLeft:18, margin:0}}>
        {ordered.map((row, i) => {
          const name = row.player?.name ?? `${row.player?.firstName ?? ""} ${row.player?.lastName ?? ""}`.trim();
          const isChosen = row.pid === chosenPid;
          return (
            <li key={row.pid} style={{padding: "2px 0"}}>
              <span style={{fontWeight: isChosen ? 800 : 500}}>
                {name}
              </span>
              <span style={{opacity:.7}}> — WS {row.ws.toFixed(1)}</span>
            </li>
          );
        })}
      </ol>
    </div>
  );
}

Make sure when you open the modal for a cell you pass:
	•	rarity, rarityRank, eligibleCount for the chosen player
	•	ordered from the cell’s cached maps
	•	chosenPid = the guessed player’s pid

6) Copy/text clean-up
	•	Remove any “lower = better” strings.
	•	If you show a small hint anywhere, use:
	•	“Rarity scores: higher = more rare.”
	•	Tile chip already shows color: red (common) → green (rare).

7) Sanity test (please run)
	1.	In a cell with many eligibles, pick a superstar → chip should be red with a low number (e.g., 8), rank near 1.
	2.	Pick a fringe name → chip should be green with a high number (e.g., 88), rank near N.
	3.	Open the modal: the Rarity section shows the same number + “Rank X of N”.
	4.	In Other Answers, confirm the chosen player appears exactly at that WS rank.
