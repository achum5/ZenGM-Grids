“Unified BBGM-style league uploads (URL + file, JSON + GZ) with client-side parse + tiny proxy”

0) Context (do not skip)

Our core problem: In Replit preview the old flow posted a huge league JSON to our own /api/* routes (worked locally). On Vercel those routes don’t exist (404 HTML responses) and even if they did, sending multi-MB payloads to serverless times out or blows memory.

The fix (like BBGM): Do everything in the browser (read → gunzip → JSON.parse) and use only a tiny URL proxy to fetch Dropbox/GitHub/Gist/Drive links. No giant POSTs of league data. Offload parsing to a Web Worker so the UI never locks up.

Unified: Use the same approach in Replit preview and Vercel. One codepath. Fewer bugs.

1) Dependencies
npm i fflate

2) Vercel serverless proxy (for URL imports)

Create api/fetch-league.ts at repo root:

import type { VercelRequest, VercelResponse } from "@vercel/node";
import { Readable } from "node:stream";

export const config = { maxDuration: 60 };

const UA =
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36";

function normalize(input: string) {
  const u = new URL(input.trim());

  // Dropbox → direct (keep tokens; force dl=1)
  if (
    u.hostname === "www.dropbox.com" ||
    u.hostname === "dropbox.com" ||
    u.hostname === "dl.dropbox.com" ||
    u.hostname.endsWith("dropbox.com")
  ) {
    u.hostname = "dl.dropboxusercontent.com";
    u.searchParams.set("dl", "1");
  }

  // GitHub blob → raw
  if (u.hostname === "github.com") {
    const p = u.pathname.split("/").filter(Boolean);
    if (p.length >= 5 && p[2] === "blob") {
      const [user, repo, _blob, branch, ...rest] = p;
      u.hostname = "raw.githubusercontent.com";
      u.pathname = `/${user}/${repo}/${branch}/${rest.join("/")}`;
      u.search = "";
    }
  }

  // Gist page → raw
  if (u.hostname === "gist.github.com") {
    const p = u.pathname.split("/").filter(Boolean);
    if (p.length >= 2) {
      const [user, hash] = p;
      u.hostname = "gist.githubusercontent.com";
      u.pathname = `/${user}/${hash}/raw`;
      u.search = "";
    }
  }

  // Google Drive file → direct
  if (u.hostname === "drive.google.com" && u.pathname.startsWith("/file/")) {
    const id = u.pathname.split("/")[3];
    u.pathname = "/uc";
    u.search = "";
    u.searchParams.set("export", "download");
    u.searchParams.set("id", id);
  }

  if (!/^https?:$/.test(u.protocol)) throw new Error("Only http(s) URLs are allowed.");
  return u.toString();
}

export default async function handler(req: VercelRequest, res: VercelResponse) {
  try {
    const url = typeof req.query.url === "string" ? req.query.url : "";
    if (!url) return res.status(400).json({ error: "Missing ?url=" });

    const normalized = normalize(url);
    const looksGzipByExt = /\.json\.gz$|\.gz$/i.test(new URL(normalized).pathname);

    const upstream = await fetch(normalized, {
      redirect: "follow",
      headers: { "User-Agent": UA, Accept: "*/*", "Accept-Encoding": "identity" }, // avoid extra gzip
    });

    if (!upstream.ok || !upstream.body) {
      return res
        .status(upstream.status || 502)
        .json({ error: `Fetch failed: remote ${upstream.status} ${upstream.statusText}` });
    }

    const ct = upstream.headers.get("content-type") || "application/octet-stream";
    res.setHeader("Content-Type", ct);

    // Hint gzip to client even if server omits Content-Encoding
    const ce = upstream.headers.get("content-encoding");
    const isGzipType = /\b(gzip|x-gzip)\b/i.test(ct) || /application\/(gzip|x-gzip)/i.test(ct);
    if (ce) res.setHeader("X-Content-Encoding", ce);
    else if (looksGzipByExt || isGzipType) res.setHeader("X-Content-Encoding", "gzip");

    res.setHeader("Cache-Control", "no-store");
    Readable.fromWeb(upstream.body as any).pipe(res);
  } catch (e: any) {
    res.status(400).json({ error: String(e?.message || e) });
  }
}


Create vercel.json:

{
  "functions": {
    "api/**": { "maxDuration": 60 }
  }
}


Vercel settings: Framework Vite, Build npm run build, Output dist/public. No Next.js.

3) Dev parity (Replit preview)

Add the same proxy route to your dev server so /api/fetch-league works locally too.
Open server/routes.ts (or wherever Express routes live) and add:

import { Router } from "express";
import { Readable } from "node:stream";

const router = Router();

router.get("/api/fetch-league", async (req, res) => {
  try {
    const raw = String(req.query.url || "");
    if (!raw) return res.status(400).json({ error: "Missing ?url=" });

    const normalize = (input: string) => {
      const u = new URL(input.trim());
      if (
        u.hostname === "www.dropbox.com" ||
        u.hostname === "dropbox.com" ||
        u.hostname === "dl.dropbox.com" ||
        u.hostname.endsWith("dropbox.com")
      ) {
        u.hostname = "dl.dropboxusercontent.com";
        u.searchParams.set("dl", "1");
      }
      if (u.hostname === "github.com") {
        const p = u.pathname.split("/").filter(Boolean);
        if (p.length >= 5 && p[2] === "blob") {
          const [user, repo, _blob, branch, ...rest] = p;
          u.hostname = "raw.githubusercontent.com";
          u.pathname = `/${user}/${repo}/${branch}/${rest.join("/")}`;
          u.search = "";
        }
      }
      if (u.hostname === "gist.github.com") {
        const p = u.pathname.split("/").filter(Boolean);
        if (p.length >= 2) {
          const [user, hash] = p;
          u.hostname = "gist.githubusercontent.com";
          u.pathname = `/${user}/${hash}/raw`;
          u.search = "";
        }
      }
      if (u.hostname === "drive.google.com" && u.pathname.startsWith("/file/")) {
        const id = u.pathname.split("/")[3];
        u.pathname = "/uc";
        u.search = "";
        u.searchParams.set("export", "download");
        u.searchParams.set("id", id);
      }
      if (!/^https?:$/.test(u.protocol)) throw new Error("Only http(s) URLs are allowed.");
      return u.toString();
    };

    const normalized = normalize(raw);
    const looksGzipByExt = /\.json\.gz$|\.gz$/i.test(new URL(normalized).pathname);

    const upstream = await fetch(normalized, {
      redirect: "follow",
      headers: { "User-Agent": "ReplitDevProxy/1.0", Accept: "*/*", "Accept-Encoding": "identity" },
    });

    if (!upstream.ok || !upstream.body) {
      return res
        .status(upstream.status || 502)
        .json({ error: `Fetch failed: remote ${upstream.status} ${upstream.statusText}` });
    }

    const ct = upstream.headers.get("content-type") || "application/octet-stream";
    res.setHeader("Content-Type", ct);
    const ce = upstream.headers.get("content-encoding");
    const isGzipType = /\b(gzip|x-gzip)\b/i.test(ct) || /application\/(gzip|x-gzip)/i.test(ct);
    if (ce) res.setHeader("X-Content-Encoding", ce);
    else if (looksGzipByExt || isGzipType) res.setHeader("X-Content-Encoding", "gzip");

    res.setHeader("Cache-Control", "no-store");
    Readable.fromWeb(upstream.body as any).pipe(res);
  } catch (err: any) {
    res.status(400).json({ error: String(err?.message || err) });
  }
});

export default router;


Mount this router where your server mounts others (keep existing routes untouched).

4) Client helpers (one codepath)

Create client/src/lib/leagueIO.ts:

import { gunzipSync } from "fflate";

export async function fetchLeagueBytes(url: string) {
  const r = await fetch(`/api/fetch-league?url=${encodeURIComponent(url)}`);
  if (!r.ok) {
    const text = await r.text().catch(() => "");
    throw new Error(`URL fetch failed (${r.status}): ${text || r.statusText}`);
  }
  const hinted = r.headers.get("x-content-encoding") as ("gzip" | null);
  const bytes = new Uint8Array(await r.arrayBuffer());
  return { bytes, hinted };
}

export async function fileToBytes(file: File) {
  const bytes = new Uint8Array(await file.arrayBuffer());
  const hinted = file.name.toLowerCase().endsWith(".gz") ? ("gzip" as const) : null;
  return { bytes, hinted };
}

// Optional sync fallback for small files
export function parseLeagueSync(bytes: Uint8Array, hinted?: "gzip" | null) {
  const needGzip = hinted === "gzip" || (bytes[0] === 0x1f && bytes[1] === 0x8b);
  const raw = needGzip ? gunzipSync(bytes) : bytes;
  const text = new TextDecoder().decode(raw);
  return JSON.parse(text);
}


Create client/src/workers/leagueParse.worker.ts:

import { gunzip } from "fflate";
const isGzip = (u8: Uint8Array) => u8.length >= 2 && u8[0] === 0x1f && u8[1] === 0x8b;

self.onmessage = async (e: MessageEvent) => {
  try {
    const { bytes, hinted } = e.data as { bytes: ArrayBuffer; hinted?: "gzip" | null };
    let u8 = new Uint8Array(bytes); // transferred, zero-copy

    if (hinted === "gzip" || isGzip(u8)) {
      u8 = await new Promise<Uint8Array>((resolve, reject) => {
        gunzip(u8, (err, out) => (err ? reject(err) : resolve(out)));
      });
    }

    const text = new TextDecoder().decode(u8);
    const league = JSON.parse(text);
    (self as any).postMessage({ ok: true, league });
  } catch (err: any) {
    (self as any).postMessage({ ok: false, error: String(err?.message || err) });
  }
};


Append to leagueIO.ts:

export async function parseLeagueInWorker(bytes: Uint8Array, hinted: "gzip" | null) {
  const ab = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
  const worker = new Worker(new URL("../workers/leagueParse.worker.ts", import.meta.url), { type: "module" });

  return new Promise<any>((resolve, reject) => {
    const cleanup = () => worker.terminate();
    worker.onmessage = (e) => {
      cleanup();
      const { ok, league, error } = e.data || {};
      ok ? resolve(league) : reject(new Error(error || "Parse failed"));
    };
    worker.onerror = (ev) => {
      cleanup();
      reject(new Error(ev.message || "Worker error"));
    };
    worker.postMessage({ bytes: ab, hinted }, [ab as any]); // transfer, no copies
  });
}

5) Integrate in your existing upload UI (do NOT change your UI/game code)

Open your current upload component and only swap the loader:

import { fetchLeagueBytes, fileToBytes, parseLeagueInWorker } from "@/lib/leagueIO";

async function onUrlSubmit(inputUrl: string) {
  setLoading(true);
  try {
    const { bytes, hinted } = await fetchLeagueBytes(inputUrl);
    const league = await parseLeagueInWorker(bytes, hinted);
    // DO NOT POST to /api/*
    // Hand 'league' to the exact same place your UI/game expects (unchanged):
    // e.g. startGame(league) / setLeagueState(league) / navigate with state, etc.
  } catch (e: any) {
    toast.error(e.message || "Failed to load URL");
  } finally {
    setLoading(false);
  }
}

async function onFileChosen(file: File) {
  setLoading(true);
  try {
    const { bytes, hinted } = await fileToBytes(file);
    const league = await parseLeagueInWorker(bytes, hinted);
    // Same: use league directly in client state / game init
  } catch (e: any) {
    toast.error(e.message || "Failed to load file");
  } finally {
    setLoading(false);
  }
}


Make sure the file input allows gzip:

<input type="file" accept=".json,.gz,application/gzip,application/x-gzip" />


Important: Remove or disable any remaining calls to /api/process-league, /api/generate-grid, etc. After this change, the only /api/* request should be /api/fetch-league (for URLs). Local files never hit the server.

6) Error handling (bulletproof)

If /api/fetch-league returns non-200, read .text() and show it in the UI — helps diagnose Dropbox/Drive permission pages.

If content looks like HTML (starts with <), throw a friendly error (“This link returns a web page, not a file. Make sure it’s a direct download.”).

For Google Drive, users must set “anyone with the link” or you’ll get an auth page.

Drop references to big byte arrays once parsed (let GC reclaim).

Worker errors should surface cleanly (we already post error back).

7) QA checklist

Preview (Replit):

GET /api/fetch-league?url=<dropbox.gz> streams bytes (not HTML).

Upload local .json and .gz → both load; UI remains responsive.

Vercel:

Visit /api/fetch-league?url=<dropbox_or_github_raw_or_drive> → bytes stream.

In-app: URL and file imports for .json and .gz both work.

Network tab: no calls to /api/process-league etc.—only /api/fetch-league.