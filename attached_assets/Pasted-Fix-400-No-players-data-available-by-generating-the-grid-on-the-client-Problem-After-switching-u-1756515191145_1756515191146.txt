Fix 400 “No players data available” by generating the grid on the client

Problem

After switching uploads to client-side, the server’s /api/...generate... route has no players in memory.

Generate button still hits that route → 400: No players data available.

Goal

Do grid generation on the client from the already-processed FileUploadData.

Keep URL uploads (via /api/fetch-league) returning bytes only; decoding + processing still happens on the client.

1) Make grid building a pure, shared function

Create/Move the existing server transform for building a grid into a shared module.

file: shared/grid.ts

import type { FileUploadData } from "./schema"; // adjust path

export type BuiltGrid = {
  // whatever your UI expects to render a grid
  // rows, cols, metadata, etc.
};

export function buildGridFromFileUploadData(data: FileUploadData): BuiltGrid {
  // ⬇️ Move the logic that server used to construct the grid
  // from players/teams/etc in FileUploadData.
  // IMPORTANT: no I/O here, just pure computation.
  // return { ... };
  throw new Error("Implement me from server logic");
}


Copy the grid-construction logic from server/routes.ts (where you previously built a grid) into this function.

2) Use that function in the client after upload completes

file: client/src/pages/home.tsx (or wherever the upload + generate button lives)

"use client";
import { useState } from "react";
import UploadLeague from "@/components/UploadLeague";
import type { FileUploadData } from "@/shared/schema";
import { buildGridFromFileUploadData } from "@/shared/grid";

export default function HomePage() {
  const [fileData, setFileData] = useState<FileUploadData | null>(null);
  const [grid, setGrid] = useState<any>(null);

  return (
    <main className="p-6 space-y-4">
      <UploadLeague onComplete={(data) => setFileData(data)} />

      <button
        className="rounded-xl bg-orange-500 px-4 py-2 text-white disabled:opacity-50"
        disabled={!fileData}
        onClick={() => {
          if (!fileData) return;
          try {
            const g = buildGridFromFileUploadData(fileData);
            setGrid(g);
          } catch (e: any) {
            console.error(e);
            alert(e?.message || "Failed to build grid");
          }
        }}
      >
        Generate Grid
      </button>

      {grid && (
        // your existing grid renderer
        // <GridView grid={grid} />
        <pre className="text-xs bg-black/40 p-3 rounded">{JSON.stringify(grid,null,2)}</pre>
      )}
    </main>
  );
}


Important: remove any call to /api/*generate* for the local/URL flows. The generate step should be pure client code now.

3) Ensure the upload flow sets FileUploadData correctly

You already have processLeagueClient(raw) returning FileUploadData. Make sure it actually populates the arrays the grid builder expects:

file: client/src/lib/clientLeagueProcessor.ts

export async function processLeagueClient(raw: any): Promise<FileUploadData> {
  // Must return data.players (length > 0) and whatever else buildGridFromFileUploadData uses.
  // If the BBGM export wraps data (e.g., {players:[...]} vs {league:{players:[...]}}),
  // normalize it here so data.players exists.
  // return { players, teams, ... }
}


If your BBGM JSON sometimes nests under league, normalize:

const src = raw?.players?.length ? raw : raw?.league ?? raw;

4) Kill the server dependency for generate (search & remove)

Search for any remaining server generate calls and remove/guard them:

rg -n "/api/.*generate" client/src
rg -n "generateGrid" server client


Any generate action for the local/URL paths should be replaced with the client call to buildGridFromFileUploadData(fileData).

5) Keep URL uploads exactly as we set them

/api/fetch-league returns bytes + X-Content-Encoding.

Client decodes with decodeLeagueBytes and then calls processLeagueClient → setFileData.

No other server routes are needed for local/URL upload + generate.

(Optional) If you insist on server-side generate

Create a POST route that accepts FileUploadData in the body, builds, and returns the grid. Do not rely on server memory.

Vercel function: api/generate-grid.ts

import type { VercelRequest, VercelResponse } from "@vercel/node";
import { buildGridFromFileUploadData } from "../shared/grid";

export default async function handler(req: VercelRequest, res: VercelResponse) {
  if (req.method !== "POST") return res.status(405).send("Method Not Allowed");
  try {
    const data = req.body; // Vercel parses JSON by default for node functions
    if (!data?.players?.length) {
      return res.status(400).json({ message: "No players data available. Please upload a league file first." });
    }
    const grid = buildGridFromFileUploadData(data);
    return res.status(200).json(grid);
  } catch (e: any) {
    console.error(e);
    return res.status(500).json({ message: e?.message || "internal error" });
  }
}


Client call:

const grid = await fetch("/api/generate-grid", {
  method: "POST",
  headers: { "content-type": "application/json" },
  body: JSON.stringify(fileData),
}).then(r => r.json());

Sanity checklist (Vercel)

Local .json and .json.gz → upload → Generate Grid builds on client, no server generate call, and no “No players data” errors.

URL upload → bytes via /api/fetch-league → decode → process → Generate Grid on client.

If you use the optional server POST, it works because you send FileUploadData in the request body.

Why this fixes your 400: the server was empty because we stopped uploading to it. By generating the grid from the client’s processed data (or POSTing that exact data if you keep a server route), we eliminate the mismatch and the error goes away.



BE SURE TO NOT CHANGE ANY UI COMPONENTS