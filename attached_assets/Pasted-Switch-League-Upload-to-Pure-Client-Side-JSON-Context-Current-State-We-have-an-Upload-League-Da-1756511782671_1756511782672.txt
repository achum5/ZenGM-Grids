Switch League Upload to Pure Client-Side JSON

Context / Current State

We have an “Upload League Data” page with tabs for File Upload and URL Upload.

In Replit Preview it appears to work, but on Vercel the upload path sometimes calls an API route and then tries res.json(), which returns Vercel’s HTML error page → “Unexpected token 'T'… not valid JSON”.

We want the easy way: for plain .json files only, read the file entirely in the browser, JSON.parse it, and pass the data into our grid builder. No server/API call at all for this path.

Goal

Add a client-only uploader that accepts .json, reads it with File.text(), JSON.parses it, and hands the result to our existing grid creation logic.

Keep any gz/URL functionality separate; do not involve it in this task.

Must work identically on Replit Preview and on Vercel because it never hits /api/*.

Acceptance Criteria

Selecting or dragging a .json file immediately loads the league in the browser—no network request.

If the file is not .json, show a friendly error (“This uploader only accepts .json”).

On success, call our grid builder (e.g., buildGridFromLeague(data)) and render the grid.

No fetch calls happen for this uploader. No calls to /api/*.

If JSON.parse fails, surface the error message in the UI.

Implementation Steps

Create a client component UploadLeague.tsx and use it on the Upload page.

Wire its onLoaded callback to our existing grid creation path (replace any old upload handler that was calling an API).

Ensure the input accepts only .json.

Keep the URL Upload / gz flow untouched (can be on another tab or hidden for now).

Code to Add (TypeScript/React, works in Next.js app router too)

// app/components/UploadLeague.tsx  (or src/components)
// If Next.js app router, keep "use client".
"use client";
import React, { useRef, useState } from "react";

type LeagueData = any; // replace with your BBGM league type if available

export default function UploadLeague({
  onLoaded,
}: {
  onLoaded: (data: LeagueData, file: File) => void;
}) {
  const [error, setError] = useState<string | null>(null);
  const [busy, setBusy] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);

  async function handleFile(file: File) {
    setError(null);
    setBusy(true);
    try {
      const isJson = file.name.toLowerCase().endsWith(".json");
      if (!isJson) {
        throw new Error("This uploader only accepts plain .json files.");
      }
      const text = await file.text();         // ← Browser only, no server
      const data = JSON.parse(text);          // ← Easy way
      onLoaded(data, file);                   // ← Hand off to app
    } catch (e: any) {
      setError(e?.message || "Failed to read or parse JSON.");
    } finally {
      setBusy(false);
    }
  }

  function onInputChange(e: React.ChangeEvent<HTMLInputElement>) {
    const f = e.target.files?.[0];
    if (f) handleFile(f);
    if (inputRef.current) inputRef.current.value = ""; // allow re-select same file
  }

  function onDrop(e: React.DragEvent<HTMLDivElement>) {
    e.preventDefault();
    const f = e.dataTransfer.files?.[0];
    if (f) handleFile(f);
  }

  return (
    <div
      onDragOver={(e) => e.preventDefault()}
      onDrop={onDrop}
      className="rounded-2xl border border-dashed p-6 text-center"
    >
      <p className="mb-3 font-medium">Upload League (.json only)</p>

      <input
        ref={inputRef}
        type="file"
        accept="application/json,.json"
        onChange={onInputChange}
        disabled={busy}
        className="hidden"
        id="leagueJsonInput"
      />
      <label
        htmlFor="leagueJsonInput"
        className="inline-block cursor-pointer rounded-xl px-4 py-2 text-white bg-orange-500 hover:opacity-90"
      >
        {busy ? "Reading…" : "Browse .json"}
      </label>

      <p className="mt-3 text-sm opacity-70">
        Or drag & drop a <code>.json</code> file here
      </p>

      {error && <p className="mt-3 text-red-500 text-sm">{error}</p>}
    </div>
  );
}


Wire It Up

// app/upload/page.tsx  (or wherever the Upload page lives)
"use client";
import UploadLeague from "@/components/UploadLeague";
// import { buildGridFromLeague } from "@/lib/grid"; // adjust path

export default function UploadPage() {
  // any state you currently use to render the grid
  // const [grid, setGrid] = useState<Grid | null>(null);

  return (
    <main className="p-6">
      <UploadLeague
        onLoaded={(leagueData) => {
          // Replace the next lines with your real grid logic
          // const grid = buildGridFromLeague(leagueData);
          // setGrid(grid);
          console.log("League loaded:", leagueData);
        }}
      />
      {/* {grid && <GridView grid={grid} />} */}
    </main>
  );
}


Deletions / Safeguards

Remove or bypass any code path that, for file uploads, calls fetch('/api/...') or await res.json(). For this JSON uploader there should be no network request.

Do not try to handle .json.gz here. That is a separate flow.

Manual Test Plan

Select a valid BBGM .json export → grid renders, console logs the object, no network requests fired.

Select a non-JSON file → error message “This uploader only accepts plain .json files.”

Corrupt JSON file → error shows the JSON parse failure.

Deploy to Vercel → repeat steps 1–3; behavior identical to Replit Preview.

If you follow the above, uploads for plain JSON will be 100% client-side and immune to the “Unexpected token 'T'” Vercel API error.