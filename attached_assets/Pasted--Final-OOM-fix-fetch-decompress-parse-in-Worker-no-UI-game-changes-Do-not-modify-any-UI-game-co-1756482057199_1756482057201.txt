“Final OOM fix: fetch+decompress+parse in Worker (no UI/game changes)”

Do not modify any UI/game code except the two upload handlers.
We’re only adding a worker and small helpers.

0) Make sure fflate is installed
npm i fflate

1) Replace the worker with a fetch-in-worker version

Create/replace: client/src/workers/leagueParse.worker.ts

// Worker: fetch/decompress/parse big BBGM leagues without main-thread memory spikes.
// - URL case: worker fetches /api/fetch-league?url=... (no big ArrayBuffer on main)
// - File case: pass File/Blob to worker; stream it through DecompressionStream if needed
// - Thins known heavy props before posting back to reduce memory.

import { AsyncGunzip } from "fflate";

type MsgIn =
  | { kind: "url"; url: string; hinted?: "gzip" | null }
  | { kind: "file"; file: Blob; hinted?: "gzip" | null };

type MsgOut = { ok: true; league: any } | { ok: false; error: string };

function isGzip(u8: Uint8Array) {
  return u8.length >= 2 && u8[0] === 0x1f && u8[1] === 0x8b;
}

async function streamToText(stream: ReadableStream<Uint8Array>): Promise<string> {
  // Let the browser handle decoding to text
  return await new Response(stream).text();
}

async function gunzipStream(stream: ReadableStream<Uint8Array>): Promise<ReadableStream<Uint8Array>> {
  if (typeof (self as any).DecompressionStream === "function") {
    // Native streaming gunzip
    const ds = new (self as any).DecompressionStream("gzip");
    return stream.pipeThrough(ds) as ReadableStream<Uint8Array>;
  }
  // Fallback: fflate AsyncGunzip → return a readable stream
  const reader = stream.getReader();
  const gunzip = new AsyncGunzip();
  let controllerResolve: (s: ReadableStream<Uint8Array>) => void;
  const out = new ReadableStream<Uint8Array>({
    start(controller) {
      gunzip.ondata = (chunk) => controller.enqueue(chunk);
      gunzip.onerr = (msg, code) => controller.error(new Error(`${msg} (${code})`));
      gunzip.onend = () => controller.close();
      controllerResolve = () => {};
    },
  });
  (async () => {
    try {
      for (;;) {
        const { value, done } = await reader.read();
        if (done) break;
        gunzip.push(value, false);
      }
      gunzip.push(new Uint8Array(0), true);
    } catch (e) {
      // If anything goes wrong while reading/pushing
      (out as any).cancel?.(e);
    }
  })();
  return out;
}

function thinLeagueInPlace(league: any) {
  // Keep the parts you actually need; drop huge history to avoid OOM.
  // Adjust this list as needed—it's safe: we don't touch UI/game code here.
  const dropTopLevel = [
    "events", "games", "gameStats", "boxScores", "schedule",
    "playoffSeries", "releasedPlayers", "awards",
    "draftLotteryResults", "allStars", "messages",
  ];
  for (const k of dropTopLevel) {
    if (k in league) delete league[k];
  }
  // If there are season arrays, drop deep history if you don't need it
  if (Array.isArray(league?.teams)) {
    for (const t of league.teams) {
      if (Array.isArray(t?.seasons) && t.seasons.length > 4) {
        t.seasons = t.seasons.slice(-4); // last 4 seasons only
      }
      if (Array.isArray(t?.stats) && t.stats.length > 6) {
        t.stats = t.stats.slice(-6);
      }
    }
  }
  if (Array.isArray(league?.players)) {
    for (const p of league.players) {
      if (Array.isArray(p?.stats) && p.stats.length > 10) {
        p.stats = p.stats.slice(-10);
      }
      if (Array.isArray(p?.injuries) && p.injuries.length > 10) {
        p.injuries = p.injuries.slice(-10);
      }
    }
  }
}

self.onmessage = async (e: MessageEvent<MsgIn>) => {
  try {
    let stream: ReadableStream<Uint8Array>;
    let hinted = e.data.hinted ?? null;

    if (e.data.kind === "url") {
      const r = await fetch(`/api/fetch-league?url=${encodeURIComponent(e.data.url)}`);
      if (!r.ok) throw new Error(`URL fetch failed (${r.status})`);
      hinted = (r.headers.get("x-content-encoding") as ("gzip" | null)) ?? hinted;
      stream = r.body as ReadableStream<Uint8Array>;
      if (!stream) throw new Error("Readable stream not available from fetch");
    } else {
      // File/Blob path
      stream = (e.data.file as Blob).stream() as ReadableStream<Uint8Array>;
    }

    // Peek first bytes to detect gzip when not hinted
    const tee = stream.tee();
    const reader = tee[0].getReader();
    const first = await reader.read();
    reader.releaseLock();
    stream = tee[1];

    let useStream = stream;
    if (hinted === "gzip" || (first.value && isGzip(first.value))) {
      useStream = await gunzipStream(stream);
    }

    const text = await streamToText(useStream);
    const league = JSON.parse(text);

    // Thin big fields to keep memory low
    thinLeagueInPlace(league);

    (self as any).postMessage({ ok: true, league } as MsgOut);
  } catch (err: any) {
    (self as any).postMessage({ ok: false, error: String(err?.message || err) } as MsgOut);
  }
};

2) Update the helper to use the worker directly (no ArrayBuffer on main)

Create/replace: client/src/lib/leagueIO.ts

// Helper: dispatch work to the worker. No ArrayBuffer allocations on main thread.

export function parseLeagueFromUrlInWorker(url: string, hinted?: "gzip" | null): Promise<any> {
  return new Promise((resolve, reject) => {
    const worker = new Worker(new URL("../workers/leagueParse.worker.ts", import.meta.url), { type: "module" });
    worker.onmessage = (ev: MessageEvent<{ ok: boolean; league?: any; error?: string }>) => {
      if (ev.data.ok) resolve(ev.data.league);
      else reject(new Error(ev.data.error || "Worker parse failed"));
      worker.terminate();
    };
    worker.onerror = (e) => { reject(new Error(e.message || "Worker error")); worker.terminate(); };
    worker.postMessage({ kind: "url", url, hinted: hinted ?? null });
  });
}

export function parseLeagueFromFileInWorker(file: File, hinted?: "gzip" | null): Promise<any> {
  return new Promise((resolve, reject) => {
    const worker = new Worker(new URL("../workers/leagueParse.worker.ts", import.meta.url), { type: "module" });
    worker.onmessage = (ev: MessageEvent<{ ok: boolean; league?: any; error?: string }>) => {
      if (ev.data.ok) resolve(ev.data.league);
      else reject(new Error(ev.data.error || "Worker parse failed"));
      worker.terminate();
    };
    worker.onerror = (e) => { reject(new Error(e.message || "Worker error")); worker.terminate(); };
    worker.postMessage({ kind: "file", file, hinted: hinted ?? null });
  });
}


Note: We no longer create Uint8Array/arrayBuffer() on the main thread at all.

3) Change ONLY the two upload handlers to call these helpers

(Do not change any other UI/game code.)

import { parseLeagueFromUrlInWorker, parseLeagueFromFileInWorker } from "@/lib/leagueIO";
import { setLeagueInMemory } from "@/lib/leagueMemory";

// URL handler (unchanged UI)
async function onUrlSubmit(url: string) {
  setLoading(true);
  try {
    const league = await parseLeagueFromUrlInWorker(url);
    setLeagueInMemory(league);
    // call your existing game/UI function with `league`
  } catch (e: any) { console.error(e); toast?.error?.(e.message || "Failed to load URL"); }
  finally { setLoading(false); }
}

// File handler (unchanged UI)
async function onFileChosen(file: File) {
  setLoading(true);
  try {
    const hinted = file.name.toLowerCase().endsWith(".gz") ? ("gzip" as const) : null;
    const league = await parseLeagueFromFileInWorker(file, hinted);
    setLeagueInMemory(league);
    // call your existing game/UI function with `league`
  } catch (e: any) { console.error(e); toast?.error?.(e.message || "Failed to load file"); }
  finally { setLoading(false); }
}


Ensure your file input accepts gzip:

<input type="file" accept=".json,.gz,application/gzip,application/x-gzip" />