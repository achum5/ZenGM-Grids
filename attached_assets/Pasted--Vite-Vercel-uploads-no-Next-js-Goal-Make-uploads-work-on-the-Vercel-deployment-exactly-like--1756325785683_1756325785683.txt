“Vite + Vercel uploads (no Next.js)”

Goal: Make uploads work on the Vercel deployment exactly like Replit preview.
We are a Vite app with a Node Serverless Function under api/. Do not use Next.js types or files.

1) Package.json cleanup

Remove any next dependency that may have been added.

Ensure these entries exist:

{
  "engines": { "node": ">=20" },
  "dependencies": {
    "formidable": "^3.5.4"
  },
  "devDependencies": {
    "@vercel/node": "^3.0.0"
  }
}


Keep all other existing deps/scripts. Do not change the build script (vite build) or anything in /server used for local dev.

2) Create/overwrite api/fetch-league.ts (Vercel Function)

Use @vercel/node types, not Next.js. This function must:

GET ?url=… → normalize Dropbox/GitHub/Gist/Drive links and stream bytes through with Accept-Encoding: identity.

POST (multipart or raw) → accept local .json or .gz files and return raw bytes; set X-Content-Encoding: gzip when gz.

// api/fetch-league.ts
import type { VercelRequest, VercelResponse } from "@vercel/node";
import formidable from "formidable";
import { promises as fsp } from "node:fs";
import { Readable } from "node:stream";

export const config = { maxDuration: 60 }; // extend function timeout

const UA =
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36";

function normalizeLeagueUrl(input: string): string {
  const u = new URL(input.trim());

  // Dropbox share -> direct
  if (u.hostname.endsWith("dropbox.com")) {
    u.hostname = "dl.dropboxusercontent.com";
    u.searchParams.set("dl", "1");
    u.searchParams.delete("st");
  }
  if (u.hostname === "dl.dropboxusercontent.com") {
    u.searchParams.delete("st");
  }

  // GitHub blob -> raw
  if (u.hostname === "github.com") {
    const parts = u.pathname.split("/").filter(Boolean);
    if (parts.length >= 5 && parts[2] === "blob") {
      const [user, repo, _blob, branch, ...rest] = parts;
      u.hostname = "raw.githubusercontent.com";
      u.pathname = `/${user}/${repo}/${branch}/${rest.join("/")}`;
      u.search = "";
    }
  }

  // Gist page -> raw
  if (u.hostname === "gist.github.com") {
    const parts = u.pathname.split("/").filter(Boolean);
    if (parts.length >= 2) {
      const [user, hash] = parts;
      u.hostname = "gist.githubusercontent.com";
      u.pathname = `/${user}/${hash}/raw`;
      u.search = "";
    }
  }

  // Google Drive file -> direct
  if (u.hostname === "drive.google.com" && u.pathname.startsWith("/file/")) {
    const id = u.pathname.split("/")[3];
    u.pathname = "/uc";
    u.search = "";
    u.searchParams.set("export", "download");
    u.searchParams.set("id", id);
  }

  if (!/^https?:$/.test(u.protocol)) throw new Error("Only http(s) URLs are allowed.");
  return u.toString();
}

function sniffIsGzip(buf: Uint8Array) {
  return buf.length >= 2 && buf[0] === 0x1f && buf[1] === 0x8b;
}

async function parseMultipart(req: VercelRequest): Promise<Uint8Array> {
  const form = formidable({ multiples: false, keepExtensions: true });
  const { files } = await new Promise<any>((resolve, reject) => {
    form.parse(req, (err, fields, files) => (err ? reject(err) : resolve({ fields, files })));
  });

  const fileObj = (files as any).file || (files as any).upload || Object.values(files)[0];
  if (!fileObj) throw new Error("No file provided");
  const f = Array.isArray(fileObj) ? fileObj[0] : fileObj;
  const filepath = f.filepath || f.path;
  const data = await fsp.readFile(filepath);
  // best-effort cleanup
  fsp.unlink(filepath).catch(() => {});
  return new Uint8Array(data);
}

export default async function handler(req: VercelRequest, res: VercelResponse) {
  try {
    if (req.method === "GET") {
      const url = typeof req.query.url === "string" ? req.query.url : "";
      if (!url) return res.status(400).json({ error: "Missing ?url=" });

      const normalized = normalizeLeagueUrl(url);
      const remote = await fetch(normalized, {
        redirect: "follow",
        headers: { "User-Agent": UA, Accept: "*/*", "Accept-Encoding": "identity" }
      });

      if (!remote.ok || !remote.body) {
        return res
          .status(remote.status || 502)
          .json({ error: `Fetch failed: remote ${remote.status} ${remote.statusText}` });
      }

      res.setHeader("Content-Type", remote.headers.get("content-type") || "application/octet-stream");
      const ce = remote.headers.get("content-encoding");
      if (ce) res.setHeader("X-Content-Encoding", ce);
      res.setHeader("Cache-Control", "no-store");

      const nodeStream = Readable.fromWeb(remote.body as any);
      nodeStream.pipe(res);
      return;
    }

    if (req.method === "POST") {
      const ct = req.headers["content-type"] || "";
      let bytes: Uint8Array;

      if (typeof ct === "string" && ct.includes("multipart/form-data")) {
        bytes = await parseMultipart(req);
      } else {
        // raw octet-stream
        const chunks: Buffer[] = [];
        await new Promise<void>((resolve, reject) => {
          req.on("data", (c) => chunks.push(c));
          req.on("end", () => resolve());
          req.on("error", reject);
        });
        bytes = new Uint8Array(Buffer.concat(chunks));
      }

      res.setHeader("Content-Type", "application/octet-stream");
      if (sniffIsGzip(bytes)) res.setHeader("X-Content-Encoding", "gzip");
      res.setHeader("Cache-Control", "no-store");
      res.status(200).send(Buffer.from(bytes));
      return;
    }

    res.setHeader("Allow", "GET, POST");
    res.status(405).send("Method Not Allowed");
  } catch (err: any) {
    res.status(400).json({ error: String(err?.message || err) });
  }
}

3) Fix vercel.json

Replace the file with exactly:

{
  "functions": {
    "api/**": { "runtime": "nodejs20.x", "maxDuration": 60 }
  }
}


No references to server/index.ts. All serverless functions must live under api/.

4) Don’t touch the client, just confirm the calls

URL upload:

fetch(`/api/fetch-league?url=${encodeURIComponent(inputUrl)}`)


File upload (multipart with .json or .gz):

const fd = new FormData();
fd.append("file", file);
fetch("/api/fetch-league", { method: "POST", body: fd });

5) Commit & push (you’ll do this manually)
git add -A
git commit -m "Vercel function (no Next); vercel.json fixed; uploads working"
git push


Vercel UI settings (for reference):
Framework: Vite · Build Command: npm run build · Output Directory: dist/public · Node: 20.

Please apply exactly these changes and don’t add next anywhere.