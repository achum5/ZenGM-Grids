Final fix for Leader achievements & Other Top Answers

0) Non-negotiables
	‚Ä¢	Never decide eligibility from p.achievements.includes("Led League in Blocks"). Those strings can be stale/incorrect.
	‚Ä¢	Always evaluate leaders with the computed leaders index at grid time: regular season, per-game, min games, ties allowed.

‚∏ª

A) Leaders index (RS only, per-game, min games, ties OK)

type LeaderKey = "ppg" | "rpg" | "apg" | "spg" | "bpg";

export const ACH_LEADERS = {
  LedPTS: { label: "Led League in Scoring",  key: "ppg" as LeaderKey },
  LedREB: { label: "Led League in Rebounds", key: "rpg" as LeaderKey },
  LedAST: { label: "Led League in Assists",  key: "apg" as LeaderKey },
  LedSTL: { label: "Led League in Steals",   key: "spg" as LeaderKey },
  LedBLK: { label: "Led League in Blocks",   key: "bpg" as LeaderKey },
} as const;

function seasonMinGames(numGamesBySeason: Map<number, number>, season: number) {
  const G = numGamesBySeason.get(season) ?? 82;
  return Math.ceil(0.58 * G);
}

export function buildLeadersBySeason(league: any, numGamesBySeason: Map<number, number>) {
  const bySeason = new Map<number, Array<{pid:number, s:any}>>();
  for (const p of league.players ?? []) {
    if (typeof p.pid !== "number") continue;
    for (const s of p.stats ?? []) {
      if (s.playoffs) continue;                 // RS only
      (bySeason.get(s.season) ?? bySeason.set(s.season, []).get(s.season)!).push({ pid: p.pid, s });
    }
  }
  const leaders = new Map<number, Record<LeaderKey, Set<number>>>();
  const EPS = 1e-9;

  for (const [season, arr] of bySeason) {
    const MIN = seasonMinGames(numGamesBySeason, season);
    let max = { ppg:-Infinity, rpg:-Infinity, apg:-Infinity, spg:-Infinity, bpg:-Infinity };
    const rows = arr.map(({pid, s}) => {
      const gp = s.gp ?? 0, ok = gp >= MIN;
      const ppg = (s.pts ?? 0) / (gp || 1);
      const rpg = ((s.orb ?? 0) + (s.drb ?? 0)) / (gp || 1); // REB = ORB+DRB
      const apg = (s.ast ?? 0) / (gp || 1);
      const spg = (s.stl ?? 0) / (gp || 1);
      const bpg = (s.blk ?? 0) / (gp || 1);
      if (ok) {
        max.ppg = Math.max(max.ppg, ppg);
        max.rpg = Math.max(max.rpg, rpg);
        max.apg = Math.max(max.apg, apg);
        max.spg = Math.max(max.spg, spg);
        max.bpg = Math.max(max.bpg, bpg);
      }
      return { pid, ok, ppg, rpg, apg, spg, bpg };
    });
    const set = (k:LeaderKey) => new Set(rows.filter(r => r.ok && r[k] >= (max as any)[k] - EPS).map(r => r.pid));
    leaders.set(season, { ppg:set("ppg"), rpg:set("rpg"), apg:set("apg"), spg:set("spg"), bpg:set("bpg") });
  }
  return leaders;
}

export function ledLeague(pid:number, key:LeaderKey, leadersBySeason: Map<number, Record<LeaderKey, Set<number>>>) {
  for (const sets of leadersBySeason.values()) if (sets[key]?.has(pid)) return true;
  return false;
}


‚∏ª

B) Use evaluators, not strings, everywhere
	1.	Define EVALS using the index:

EVALS.LedPTS = (p,ix)=> ledLeague(p.pid, "ppg", ix.leadersBySeason);
EVALS.LedREB = (p,ix)=> ledLeague(p.pid, "rpg", ix.leadersBySeason);
EVALS.LedAST = (p,ix)=> ledLeague(p.pid, "apg", ix.leadersBySeason);
EVALS.LedSTL = (p,ix)=> ledLeague(p.pid, "spg", ix.leadersBySeason);
EVALS.LedBLK = (p,ix)=> ledLeague(p.pid, "bpg", ix.leadersBySeason);

	2.	Validation of a guess, population counting, and Other Top Answers must all call the same evaluator:

function eligibleForCell(p: Player, row: CellSpec, col: CellSpec, ix: Indices) {
  const teamCell = row.kind === "team" ? row : col;
  const critCell = row.kind === "achievement" ? row : col;
  const teamPass = didPlayForTeam(p, teamCell.teamId);        // RS or PO ‚â•1 game
  const critPass = EVALS[critCell.achievementId](p, ix);      // ‚Üê never from strings
  return teamPass && critPass;
}

const otherAnswers = allPlayers
  .filter(q => q.pid !== chosen.pid && eligibleForCell(q, row, col, ix))
  .slice(0, 10);

If we still store p.achievements strings for display, fine ‚Äî but never use them for logic on leaders.

‚∏ª

C) Consistency audit (so Tiny can‚Äôt slip through again)

Add a one-shot audit after indices are built (on upload or server boot):

function auditLeaders(players: Player[], ix: Indices, suspectNames: string[]) {
  const byName = new Map(players.map(p => [p.name, p.pid]));
  for (const n of suspectNames) {
    const pid = byName.get(n);
    if (!pid) continue;
    const isBPG = ledLeague(pid, "bpg", ix.leadersBySeason);
    console.log(isBPG ? `‚ö†Ô∏è ${n} IS in bpg leaders (check data)` : `‚úÖ ${n} not in bpg leaders`);
  }
}

// Call once:
auditLeaders(await storage.getPlayers(), indices, ["Tiny Archibald"]);

And add a cheap invariant whenever a LedBLK cell is generated:

if (col.achievementId === "LedBLK" || row.achievementId === "LedBLK") {
  const bogus = otherAnswers.filter(p => !ledLeague(p.pid, "bpg", ix.leadersBySeason)).map(p=>p.name);
  if (bogus.length) console.warn("üö® LedBLK false positives:", bogus.slice(0,5));
}


‚∏ª

D) Clear bad data (optional safety)

If earlier runs wrote incorrect leader strings into p.achievements, clear leader tags once at upload:

const LEADER_LABELS = new Set([
  "Led League in Scoring","Led League in Rebounds","Led League in Assists","Led League in Steals","Led League in Blocks"
]);

for (const p of validatedPlayers) {
  if (Array.isArray(p.achievements)) p.achievements = p.achievements.filter(a => !LEADER_LABELS.has(a));
}
// Re-add accurate leader tags from indices if you still want them stored


‚∏ª

E) Acceptance criteria (must pass)
	‚Ä¢	‚ÄúLed League in Blocks‚Äù eligibility only when ledLeague(pid,"bpg",leadersBySeason) === true.
	‚Ä¢	Other Top Answers = team ‚àß criterion using EVALS.
	‚Ä¢	Tiny Archibald never appears for Led League in Blocks.
	‚Ä¢	Console shows no üö® LedBLK false positives during grid generation.

‚∏ª

F) Quick test procedure
	1.	Upload league ‚Üí confirm leaders index built: log number of seasons and sets sizes.
	2.	Generate a grid until ‚ÄúLed League in Blocks‚Äù appears.
	3.	In the server logs, verify zero false positives and that Tiny is reported ‚úÖ not in bpg leaders.
	4.	Manually spot-check one known BPG leader season to ensure their pid appears.
