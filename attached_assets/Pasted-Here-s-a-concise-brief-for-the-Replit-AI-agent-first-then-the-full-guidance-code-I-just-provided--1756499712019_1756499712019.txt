Here’s a concise brief for the Replit AI agent first, then the full guidance/code I just provided.

⸻

Brief for Replit AI Agent (issue + fix)

Problem: On the Vercel deployment, both File and URL uploads show the same toast: “The string did not match the expected pattern.” This is not a JSON/gzip problem. The client form validation is incorrectly treating both modes as a string/URL and running them through a regex/z.string().url() before any bytes are read. The prod build on Vercel hits that path; Replit preview didn’t.

Fix:
	1.	Use a discriminated Zod union to separate validation for file vs URL so the file path never touches a string/URL regex.
	2.	Implement the BBGM “easy way”: parse the file client-side (read bytes, detect gzip, JSON.parse) with no server upload.
	3.	For URL uploads, fetch the bytes client-side; if CORS blocks, use a tiny /api/download proxy (Node runtime) that streams bytes through.

This removes the validation error on Vercel and avoids serverless body limits.

⸻

Everything I sent (full guidance + code)

Got it—since the exact same toast fires for file and URL on Vercel, this almost certainly isn’t the JSON itself. It’s your client-side validation path treating both modes the same (a z.string().regex(...) or z.string().url()), so the “file” branch still runs through a string pattern check and explodes before you ever read bytes. Replit preview likely bypasses that path or tolerates it; the prod build on Vercel hits it every time.

Here’s a minimal, production-proof pattern that fixes it (and also keeps you on the “easy way” the BBGM dev suggested).

⸻

1) Separate the two modes with a discriminated Zod union

This guarantees the file path never hits a URL regex again.

// validation.ts
import { z } from "zod";

const FileMode = z.object({
  mode: z.literal("file"),
  file: z.custom<File>((v) => v instanceof File && v.size > 0, "Choose a league file"),
});

const UrlMode = z.object({
  mode: z.literal("url"),
  url: z.string().url("Enter a valid http(s) URL"),
});

export const UploadSchema = z.discriminatedUnion("mode", [FileMode, UrlMode]);
export type UploadInput = z.infer<typeof UploadSchema>;


⸻

2) Parse on the client (no server upload)

No body limits, no runtime differences, no multipart parsing surprises.

// UploadBox.tsx  — "use client"
import { useState } from "react";
import { UploadSchema } from "./validation";
import { gunzipSync, strFromU8 } from "fflate";

async function parseBytes(arr: Uint8Array) {
  const isGz = arr[0] === 0x1f && arr[1] === 0x8b;
  const txt = isGz ? strFromU8(gunzipSync(arr)) : new TextDecoder().decode(arr);
  if (!txt.trim().startsWith("{") && !txt.trim().startsWith("[")) {
    throw new Error("Not a valid league export (.json or .json.gz).");
  }
  return JSON.parse(txt);
}

export default function UploadBox({ onLeague }: { onLeague: (lg: any) => void }) {
  const [mode, setMode] = useState<"file" | "url">("file");
  const [busy, setBusy] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function handleFile(file?: File) {
    if (!file) return;
    setError(null); setBusy(true);
    try {
      const arr = new Uint8Array(await file.arrayBuffer());
      const league = await parseBytes(arr);
      onLeague(league);
    } catch (e: any) {
      setError(e?.message ?? "Failed to read file.");
    } finally { setBusy(false); }
  }

  async function handleUrl(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    const fd = new FormData(e.currentTarget);
    const candidate = { mode: "url", url: String(fd.get("url") || "") } as const;
    const parsed = UploadSchema.safeParse(candidate);
    if (!parsed.success) {
      setError(parsed.error.issues[0]?.message ?? "Invalid URL");
      return;
    }
    setError(null); setBusy(true);
    try {
      // If CORS blocks you, fetch through /api/download?url=… (see below)
      const res = await fetch(parsed.data.url);
      if (!res.ok) throw new Error(`Download failed: ${res.status} ${res.statusText}`);
      const arr = new Uint8Array(await res.arrayBuffer());
      const league = await parseBytes(arr);
      onLeague(league);
    } catch (e: any) {
      setError(e?.message ?? "Could not fetch that URL.");
    } finally { setBusy(false); }
  }

  return (
    <div>
      <div style={{ display: "flex", gap: 8, marginBottom: 12 }}>
        <button type="button" onClick={() => setMode("file")} aria-pressed={mode==="file"}>File Upload</button>
        <button type="button" onClick={() => setMode("url")}  aria-pressed={mode==="url"}>URL Upload</button>
      </div>

      {mode === "file" ? (
        <label style={{ display: "block", border: "2px dashed #f60", padding: 24, borderRadius: 12 }}>
          <input
            type="file"
            accept=".json,.json.gz,application/json,application/gzip,application/x-gzip"
            style={{ display: "none" }}
            onChange={(e) => handleFile(e.target.files?.[0])}
          />
          <div>Drag & drop your league file here</div>
        </label>
      ) : (
        <form onSubmit={handleUrl} style={{ display: "flex", gap: 8 }}>
          <input name="url" type="url" placeholder="https://…/league.json or .json.gz" required />
          <button type="submit" disabled={busy}>Load</button>
        </form>
      )}

      {busy && <div>Processing league…</div>}
      {error && <div style={{ color: "#b00020", marginTop: 8 }}>{error}</div>}
    </div>
  );
}

Note: only the URL path is validated as a string. The file path never touches a regex/URL rule, so your “expected pattern” toast can’t fire for files anymore.

⸻

3) Optional: proxy URLs to dodge CORS

Keep it tiny and Node-runtime so it behaves the same on Vercel and Replit.

// /app/api/download/route.ts (Next.js app router)
export const runtime = "nodejs";

export async function GET(req: Request) {
  const url = new URL(req.url).searchParams.get("url");
  if (!url) return new Response("missing url", { status: 400 });

  const upstream = await fetch(url);
  if (!upstream.ok) return new Response(`remote ${upstream.status} ${upstream.statusText}`, { status: 502 });

  const buf = Buffer.from(await upstream.arrayBuffer());
  return new Response(buf, {
    headers: {
      "Content-Type": "application/octet-stream",
      "Access-Control-Allow-Origin": "*",
      // Optional signal for your client, if you still want it:
      // "X-Content-Encoding": upstream.headers.get("content-encoding") ?? ""
    }
  });
}

Client path change (one line):

const res = await fetch(`/api/download?url=${encodeURIComponent(parsed.data.url)}`);


⸻

4) Quick sanity checks to confirm this was the issue
	•	Add a console.log of the Zod result before submit:
	•	For file mode, ensure you’re not passing { mode: 'file', url: '' } (that’s what triggers the pattern error).
	•	Try a tiny 10 KB league file—if it now works in Vercel, your previous failure was purely validation-path, not JSON size.
	•	If the URL still fails but file works, it’s CORS → use the /api/download proxy above.

⸻

Why this fixes your “both file and URL” failure
	•	The union cleanly separates validation: file uploads skip string/regex checks entirely.
	•	All parsing is client-side (BBGM’s “easy way”), so Vercel body limits and Edge/Node differences don’t matter.
	•	The proxy gives you stable URL reads when a host doesn’t send CORS headers.

If you want, paste your current schema/submit handler and I’ll convert it to this unioned version so the error can’t occur.