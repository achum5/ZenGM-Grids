Goal: Add a rarity system to the Immaculate Grid. Rarity is calculated for the eligible players of a single cell using our “prominence” model (awards + career value + rate talent + longevity), then normalized per cell so 0 = most common and 100 = rarest.
We need: (1) rarity computation utilities, (2) a per-guess rarity badge + color, and (3) a session rarity summary panel.

1) Create src/utils/rarity.ts

Use the exact implementation below (TypeScript). It expects a simple PlayerCareer adapter per player. (We’ll add the adapter in step 2.)

// src/utils/rarity.ts
export type PlayerAwards = {
  champ?: number; allStar?: number; allStarMvp?: number; mvp?: number;
  roy?: number; smoy?: number; dpoy?: number; mip?: number;
  finalsMvp?: number; sfmvp?: number;
  allLeague1?: number; allLeague2?: number; allLeague3?: number;
  allDefensive1?: number; allDefensive2?: number; allDefensive3?: number;
  allRookie?: number;
};

export type PlayerCareer = {
  pid: number;
  numSeasons: number;
  gp: number;
  min: number;
  vorp: number;
  ows: number;
  dws: number;
  per?: number;
  obpm?: number;
  dbpm?: number;
  pm100?: number;
  onOff100?: number;
  awards: PlayerAwards;
};

const W_ACC = {
  mvp: 40, finalsMvp: 25, allLeague1: 12, allLeague2: 8, allLeague3: 6,
  allDefensive1: 6, allDefensive2: 4, allDefensive3: 3,
  allStar: 6, allStarMvp: 5, dpoy: 15, roy: 8, smoy: 8, mip: 6,
  sfmvp: 8, allRookie: 2, champ: 6,
} as const;

const clamp01 = (x: number) => Math.max(0, Math.min(1, x));
const minutesFactor = (mins: number) => clamp01(Math.log1p(mins) / Math.log1p(30000));
const reliability = (gp: number, seasons: number) => clamp01(0.6*(gp/246) + 0.4*(seasons/5));
const careerValue = (vorp: number, ows: number, dws: number) => 0.6*Math.max(0, vorp) + 0.4*(ows + dws);

function accoladesScore(a: PlayerAwards): number {
  let s = 0;
  (Object.keys(W_ACC) as (keyof typeof W_ACC)[]).forEach(k => { s += (a[k] ?? 0) * W_ACC[k]; });
  return s;
}
function rateTalent(per?: number, obpm?: number, dbpm?: number, pm100?: number, onOff100?: number) {
  const perTerm = per != null ? Math.max(0, per - 15) : 0;
  const bpmTerm = (obpm ?? 0) + (dbpm ?? 0);
  const onoff = ((pm100 ?? 0) + (onOff100 ?? 0)) / 2;
  return 0.5*perTerm + 0.4*bpmTerm + 0.1*onoff;
}

export function prominence(p: PlayerCareer): number {
  const A = accoladesScore(p.awards);
  const CV = careerValue(p.vorp, p.ows, p.dws) * minutesFactor(p.min);
  const R  = reliability(p.gp, p.numSeasons);
  const RT = rateTalent(p.per, p.obpm, p.dbpm, p.pm100, p.onOff100) * R;
  const L  = 0.5 * Math.log1p(p.gp) + 0.5 * p.numSeasons;
  return 0.45*A + 0.25*CV + 0.20*RT + 0.10*L;
}

/** Normalize within a cell’s eligible set. 0=most common, 100=rarest. */
export function rarityScoresForEligible(players: PlayerCareer[]) {
  const arr = players.map(p => ({ pid: p.pid, prom: prominence(p) }));
  const min = Math.min(...arr.map(a => a.prom));
  const max = Math.max(...arr.map(a => a.prom));
  const rng = Math.max(1e-6, max - min);
  return arr.map(a => ({
    pid: a.pid,
    prom: a.prom,
    rarity: Math.round(100 * (1 - (a.prom - min) / rng))
  }));
}

/** Nice color for rarity chip (dark theme). Higher rarity → warmer/purple. */
export function rarityColor(rarity: number) {
  // 0..100 mapped to HSL: 0=teal, 50=amber, 100=violet
  const h = 180 - (rarity * 1.8); // start teal-ish → go to purple-ish via CSS hue-rotate
  // Clamp a bit nicer for dark backgrounds
  return `hsl(${Math.max(0, Math.min(300, h))}deg 80% 45%)`;
}

2) Create adapter: src/utils/careerAdapter.ts

Convert our BBGM player object (from loaded league JSON) → PlayerCareer used above. Regular season only (exclude playoffs).

// src/utils/careerAdapter.ts
import type { PlayerCareer, PlayerAwards } from "./rarity";

export function toPlayerCareerRS(player: any): PlayerCareer {
  const rs = (player.stats ?? []).filter((s: any) => s && s.playoffs === false);
  const seasons = new Set(rs.map((s: any) => s.season)).size;
  const sum = (k: string) => rs.reduce((t: number, s: any) => t + (s?.[k] ?? 0), 0);
  const avg = (k: string, fallback = 0) => {
    const vals = rs.map((s: any) => s?.[k]).filter((v: any) => v != null);
    return vals.length ? vals.reduce((a: number, b: number) => a + b, 0) / vals.length : fallback;
  };

  const awards: PlayerAwards = {};
  for (const a of (player.awards ?? [])) {
    const type = a.type;
    (awards as any)[type] = ((awards as any)[type] ?? 0) + 1;
  }

  return {
    pid: player.pid,
    numSeasons: seasons,
    gp: sum("gp"),
    min: sum("min"),
    vorp: sum("vorp"),
    ows: sum("ows"),
    dws: sum("dws"),
    per: avg("per", 15),
    obpm: avg("obpm", 0),
    dbpm: avg("dbpm", 0),
    pm100: avg("pm100", 0),
    onOff100: avg("onOff100", 0),
    awards,
  };
}

3) Cell evaluation pipeline

When a cell is rendered or when a guess is made, compute rarity within that cell’s eligible set:

Build the list of eligible players for that row/column.

Map each to toPlayerCareerRS(player).

Call rarityScoresForEligible.

Store results in a Map<pid, rarity> for that cell.

Add a small helper:

// src/logic/cellRarity.ts
import { rarityScoresForEligible } from "../utils/rarity";
import { toPlayerCareerRS } from "../utils/careerAdapter";

export function computeCellRarity(eligiblePlayers: any[]) {
  const careers = eligiblePlayers.map(toPlayerCareerRS);
  const scores = rarityScoresForEligible(careers);
  const map = new Map<number, number>();
  for (const s of scores) map.set(s.pid, s.rarity);
  return map;
}


Cache this by cell key to avoid recomputing.

4) Show rarity on guessed tiles

Keep the green/red background for correct/incorrect.

Add a rarity chip (small pill) in the bottom-right of the tile for correct guesses only. (Wrong picks show no rarity.)

Color the chip via rarityColor(rarity).

Tooltip: “Rarity (0=common, 100=rare) • Rank X of N eligible”.

// in GridCell.tsx (where we render a guessed tile)
import { rarityColor } from "../utils/rarity";

{isCorrect && typeof rarity === "number" && (
  <div
    className="rarity-chip"
    title={`Rarity ${rarity} • Rank ${rank} of ${eligibleCount}`}
    style={{
      position: "absolute",
      right: 8, bottom: 8,
      padding: "2px 8px",
      borderRadius: 999,
      fontSize: 12,
      fontWeight: 600,
      background: rarityColor(rarity),
      color: "black",
      boxShadow: "0 0 0 2px rgba(0,0,0,0.35)"
    }}
  >
    {rarity}
  </div>
)}


rarity, rank, and eligibleCount come from the cellRarity Map (rank = 1 + index when you sort descending by prominence or ascending by rarity).

5) Session rarity summary (right sidebar)

Add a panel on the right (under Session Stats) to show:

Rarity Total (sum of rarities for correct squares only)

Rarity Avg (mean of those correct squares)

Best Pick (highest rarity you made)

Obvious Pick (lowest rarity you made)

// src/components/RaritySummary.tsx
type Props = { picked: Array<{ correct: boolean; rarity?: number }> };

export default function RaritySummary({ picked }: Props) {
  const vals = picked.filter(p => p.correct && typeof p.rarity === "number").map(p => p.rarity as number);
  const total = vals.reduce((a,b)=>a+b,0);
  const avg = vals.length ? Math.round((total/vals.length)*10)/10 : 0;
  const best = vals.length ? Math.max(...vals) : 0;
  const worst = vals.length ? Math.min(...vals) : 0;

  return (
    <div className="panel card">
      <div className="title">Rarity</div>
      <div className="row"><span>Total</span><span>{total}</span></div>
      <div className="row"><span>Average</span><span>{avg}</span></div>
      <div className="row"><span>Best Pick</span><span>{best}</span></div>
      <div className="row"><span>Most Common</span><span>{worst}</span></div>
    </div>
  );
}


Mount this below “Session Stats”, and wire it to the grid state that tracks guesses.

6) Color system (simple & readable)

We keep the main tile color green/red for correctness. The rarity chip communicates rarity with color:

0–19 → “Common” → teal (hsl(170 80% 45%))

20–39 → “Uncommon” → green-lime

40–59 → “Notable” → yellow-amber

60–79 → “Rare” → orange-red

80–100 → “Ultra-rare” → violet

This is already handled by rarityColor(rarity), but you can also add discrete class thresholds if you prefer.

7) Player modal: show rarity + rank

In the player profile modal (the one with teams/stats), add a small section:

Rarity: 73 (12th of 284 eligible)


and a “Top Answers for this Square” list sorted by rarity descending (rarest first) or add a toggle to sort by commonness.

8) Edge cases

If a correct pick has no rarity (unexpected), hide the chip.

If a cell has <2 eligible players, set rarity to 50 by default.

Compute rarity once per cell and memoize; reuse when players open the modal.

Please implement all 8 steps above.
If anything is unclear (e.g., where we keep the eligible sets), ask me and I’ll point you to the files in this repo.