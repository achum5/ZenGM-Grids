Implement WS-based rarity with perfect correctness.

## What the data looks like (from our league file)
- Player stats live in `player.stats[]`
- Each row has `playoffs: boolean` (or 0/1) → **exclude playoffs**
- WS may be provided as `ws`; if not, compute as `ows + dws`
- Career WS = sum of RS rows

## 1) Utilities — create or replace: src/utils/wsRarity.ts
```ts
export type LeaguePlayer = any;

function isRS(s: any) {
  // treat undefined/false/0 as regular season
  return s && !s.playoffs;
}

/** Career Win Shares (regular season only). Uses `ws` if present, else `ows+dws`. */
export function careerWS(player: LeaguePlayer): number {
  const rows = (player?.stats ?? []).filter(isRS);
  let total = 0;
  for (const s of rows) {
    if (Number.isFinite(Number(s?.ws))) {
      total += Number(s.ws);
    } else {
      total += (Number(s?.ows) || 0) + (Number(s?.dws) || 0);
    }
  }
  return Number.isFinite(total) ? total : 0;
}

/**
 * Compute rarity for a cell:
 *  - Input: array of *eligible full player objects*
 *  - Sort DESC by WS (highest first = most common)
 *  - Rarity = reverse percentile index, 0..100 where 100 = most rare
 *  - Returns: ordered list + maps + eligibleCount
 */
export function computeCellRarityByWS(eligiblePlayers: LeaguePlayer[]) {
  const arr = eligiblePlayers.map(p => ({
    pid: p.pid,
    ws: careerWS(p),
    player: p,
  }));

  // Stable sort: DESC by WS, then pid ASC
  arr.sort((a, b) => (b.ws - a.ws) || (a.pid - b.pid));

  const N = arr.length;
  const rarityMap = new Map<number, number>();
  const rankMap   = new Map<number, number>();
  const wsMap     = new Map<number, number>();

  if (N === 0) return { ordered: [], rarityMap, rankMap, wsMap, eligibleCount: 0 };
  if (N === 1) {
    const only = arr[0];
    rarityMap.set(only.pid, 50); // neutral when only one option
    rankMap.set(only.pid, 1);
    wsMap.set(only.pid, only.ws);
    return { ordered: arr, rarityMap, rankMap, wsMap, eligibleCount: 1 };
  }

  arr.forEach((row, idx) => {
    // reverse percentile: idx=0 → 0 (common), idx=N-1 → 100 (rare)
    const rarity = Math.round(100 * (idx / (N - 1)));
    rarityMap.set(row.pid, rarity);
    rankMap.set(row.pid, idx + 1);
    wsMap.set(row.pid, row.ws);
  });

  return { ordered: arr, rarityMap, rankMap, wsMap, eligibleCount: N };
}

/** Color for rarity chip: 0=red → 100=green */
export function rarityColor(score: number) {
  const hue = Math.max(0, Math.min(120, (score / 100) * 120));
  return `hsl(${hue}deg 80% 45%)`;
}

export function rarityLabel(score: number): "Common"|"Uncommon"|"Notable"|"Rare"|"Ultra-rare" {
  if (score >= 80) return "Ultra-rare";
  if (score >= 60) return "Rare";
  if (score >= 40) return "Notable";
  if (score >= 20) return "Uncommon";
  return "Common";
}

2) Use it when a cell is built or when a correct guess is made

Where you already have eligiblePlayers for a cell (the same list you use to render “Other Answers”), call:

import { computeCellRarityByWS } from "../utils/wsRarity";

const { ordered, rarityMap, rankMap, wsMap, eligibleCount } =
  computeCellRarityByWS(eligiblePlayers);

// For the guessed player:
const pid = guessedPlayer.pid;
const rarity     = rarityMap.get(pid);     // 0..100 (100 = most rare)
const rarityRank = rankMap.get(pid);       // 1..N
const careerWS   = wsMap.get(pid);         // numeric WS total

Store those on the cell state so the grid tile and modal can read them.

3) Grid tile chip (correct guesses only) — reverse colors (0 red, 100 green)

import { rarityColor, rarityLabel } from "../utils/wsRarity";

{isCorrect && typeof rarity === "number" && (
  <div
    className="rarity-chip"
    title={`Rarity ${rarity} (${rarityLabel(rarity)}) • Rank ${rarityRank} of ${eligibleCount}`}
    style={{
      position: "absolute",
      right: 8, bottom: 8,
      padding: "2px 8px",
      borderRadius: 999,
      fontSize: 12,
      fontWeight: 700,
      background: rarityColor(rarity), // 0 red → 100 green
      color: "black",
      boxShadow: "0 0 0 2px rgba(0,0,0,.35)",
    }}
  >
    {rarity}
  </div>
)}

4) Player modal — add “Rarity” section above “Teams” and show full ordered list

Render a new card above Teams:

// Props: rarity, rarityRank, eligibleCount (from cell state)
<div className="stat-card" style={{marginBottom:12}}>
  <div style={{fontWeight:700, marginBottom:6}}>Rarity</div>
  <div style={{fontSize:28, fontWeight:800}}>{rarity}</div>
  <div style={{opacity:.8, marginTop:4}}>
    Rank {rarityRank} of {eligibleCount} eligible • {rarityLabel(rarity)}
  </div>
</div>

Rename “Other Top Answers” → “Other Answers” and list EVERY eligible player in WS rank order:

// ordered: Array<{ pid, ws, player }>
<ol style={{maxHeight:240, overflowY:"auto", paddingLeft:18, margin:0}}>
  {ordered.map((row) => {
    const p = row.player;
    const name = p?.name ?? `${p?.firstName ?? ""} ${p?.lastName ?? ""}`.trim();
    const isChosen = row.pid === chosenPid;
    return (
      <li key={row.pid} style={{padding:"2px 0"}}>
        <span style={{fontWeight: isChosen ? 800 : 500}}>
          {name}
        </span>
        <span style={{opacity:.7}}> — WS {row.ws.toFixed(1)}</span>
      </li>
    );
  })}
</ol>

5) Rarity summary under the grid — higher = better
	•	Remove any “lower = better” text.
	•	Totals/average over correct picks:

const vals = picks.filter(p => p.correct && Number.isFinite(p.rarity)).map(p => p.rarity);
const total = vals.reduce((a,b)=>a+b,0);
const avg = vals.length ? Math.round((total/vals.length)*10)/10 : 0;
const best = vals.length ? Math.max(...vals) : 0;     // highest rarity
const mostCommon = vals.length ? Math.min(...vals) : 0; // lowest rarity

6) Sanity tests (please run)
	•	Pick an obvious superstar in a crowded cell → tile chip shows low rarity (red), rank near 1.
	•	Pick a deeper cut → high rarity (green), rank near N.
	•	Modal “Other Answers” shows non-zero WS totals and the chosen player appears at the exact rank shown above.

---