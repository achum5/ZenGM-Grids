You’re right—those two bugs come from the eligibility filter and the WS calculation:
	•	The “3+ BPG in a Season” cell is likely pulling almost the whole league because the predicate is wrong.
	•	The WS list shows tons of 0.0 because career WS isn’t being summed correctly (or RS rows are filtered out).

Here’s a clean copy-paste prompt for your Replit agent that fixes both, and makes the modal list show the true eligible set ranked by career WS (RS only).

⸻


Please fix two issues in the grid logic:

1) **Eligibility is wrong** (e.g., “Averaged 3+ BPG in a Season” returns hundreds of players).
2) **Win Shares are 0.0** for most players in the modal list.

Implement the exact helpers below and use them for eligibility and WS ranking.

---

## A) Add / replace helpers in `src/logic/eligibility.ts`

```ts
// src/logic/eligibility.ts
export type LeaguePlayer = any;

/** Regular-season season rows (playoffs may be false/0/undefined) */
export function regularSeasonRows(p: LeaguePlayer) {
  return (p.stats ?? []).filter((s: any) => s && !s.playoffs);
}

/** Distinct team IDs a player appeared for (RS only) */
export function rsTeamIds(p: LeaguePlayer): number[] {
  const set = new Set<number>();
  for (const s of regularSeasonRows(p)) {
    if (typeof s.tid === "number") set.add(s.tid);
  }
  return [...set];
}

/** Career totals (RS only) */
export function rsCareerTotals(p: LeaguePlayer) {
  const rows = regularSeasonRows(p);
  let gp=0, blk=0, ast=0;
  for (const s of rows) {
    gp  += Number(s.gp  ?? 0);
    blk += Number(s.blk ?? 0);
    ast += Number(s.ast ?? 0);
  }
  return { gp, blk, ast };
}

/** Per-season checks (RS only) */
export function hasSeasonBPG(p: LeaguePlayer, minBPG: number): boolean {
  for (const s of regularSeasonRows(p)) {
    const gp  = Number(s.gp  ?? 0);
    const blk = Number(s.blk ?? 0);
    if (gp > 0 && blk / gp >= minBPG) return true;
  }
  return false;
}

/** Criteria predicates (rows x columns) */
export const criteria = {
  // Team only
  playedForTeam: (p: LeaguePlayer, tid: number) => rsTeamIds(p).includes(tid),

  // Career totals
  careerAssistsAtLeast: (p: LeaguePlayer, n: number) => rsCareerTotals(p).ast >= n,
  careerBlocksAtLeast:  (p: LeaguePlayer, n: number) => rsCareerTotals(p).blk >= n,

  // Season per-game (not tied to team)
  seasonBPGAtLeast:     (p: LeaguePlayer, bpg: number) => hasSeasonBPG(p, bpg),

  // Franchise lifer
  onlyOneTeam:          (p: LeaguePlayer) => rsTeamIds(p).length === 1,
};

Important: Season BPG must NOT be tied to team—just any RS season with blk/gp >= 3.0.

⸻

B) Win Shares for ranking (RS only) in src/utils/rarityWS.ts

// src/utils/rarityWS.ts
export type LeaguePlayer = any;

/** Career Win Shares (RS only): sum( (ows ?? 0) + (dws ?? 0) OR (ws ?? 0) ) */
export function careerWS_RS(player: LeaguePlayer): number {
  const rows = (player.stats ?? []).filter((s: any) => s && !s.playoffs);
  let ws = 0;
  for (const s of rows) {
    const ows = Number(s.ows ?? 0);
    const dws = Number(s.dws ?? 0);
    const wsRow = (ows + dws) || Number(s.ws ?? 0); // fallback if ws provided
    ws += wsRow;
  }
  return Number.isFinite(ws) ? ws : 0;
}

/** Build rarity maps from the **eligible set only** (not the whole league) */
export function computeCellRarityByWS(eligiblePlayers: LeaguePlayer[]) {
  const arr = eligiblePlayers.map(p => ({ pid: p.pid, player: p, ws: careerWS_RS(p) }));
  // DESC by WS; stable by pid
  arr.sort((a, b) => (b.ws - a.ws) || (a.pid - b.pid));

  const N = arr.length;
  const rarityMap = new Map<number, number>();
  const rankMap   = new Map<number, number>();
  const wsMap     = new Map<number, number>();

  if (N === 0) return { rarityMap, rankMap, wsMap, eligibleCount: 0, ordered: [] };
  if (N === 1) {
    rarityMap.set(arr[0].pid, 50); rankMap.set(arr[0].pid, 1); wsMap.set(arr[0].pid, arr[0].ws);
    return { rarityMap, rankMap, wsMap, eligibleCount: 1, ordered: arr };
  }

  arr.forEach((row, idx) => {
    // 100 = most rare (lowest WS), 0 = most common (highest WS)
    const rarity = Math.round(100 * (1 - idx / (N - 1)));
    rarityMap.set(row.pid, rarity);
    rankMap.set(row.pid, idx + 1);
    wsMap.set(row.pid, row.ws);
  });

  return { rarityMap, rankMap, wsMap, eligibleCount: N, ordered: arr };
}


⸻

C) Use the predicates correctly when building eligiblePlayers for each cell

Wherever the grid computes the eligible set for a (row, column):

import { criteria } from "../logic/eligibility";
import { buildCellRarityMaps } from "../logic/cellRarityByWS";

// Example wiring:
function eligibleForCell(players: any[], row: CellRow, col: CellCol) {
  // Row types: { type: "team", tid } | { type: "teamOnlyOne" } | ...
  // Col types: { type: "team" } | { type: "careerAssists", min: 5000 } | { type: "seasonBPG", min: 3 } | ...

  return players.filter(p => {
    // start true, AND each constraint
    if (row.type === "team" && !criteria.playedForTeam(p, row.tid)) return false;
    if (row.type === "teamOnlyOne" && !criteria.onlyOneTeam(p)) return false;

    if (col.type === "team" && !criteria.playedForTeam(p, col.tid)) return false;
    if (col.type === "careerAssists" && !criteria.careerAssistsAtLeast(p, col.min)) return false;
    if (col.type === "careerBlocks"  && !criteria.careerBlocksAtLeast(p,  col.min)) return false;
    if (col.type === "seasonBPG"     && !criteria.seasonBPGAtLeast(p,    col.min)) return false;

    return true;
  });
}

// Then, after you have the eligible set **for that cell**:
const maps = buildCellRarityMaps(cellKey, eligibleForCell(allPlayers, row, col));

	•	This ensures the eligible list is correct (e.g., “Averaged 3+ BPG in a Season” is only players who had blk/gp ≥ 3.0 in any RS season, regardless of team).
	•	The modal “Other Answers” must render maps.ordered (the DESC-WS eligible list), not the whole league.

⸻

D) Quick debug prints (remove later)

Add one-time logs when computing a cell:

console.debug("[cell]", cellKey,
  "eligible:", maps.eligibleCount,
  "top5:", maps.ordered.slice(0,5).map(x => ({ pid:x.pid, ws:+x.ws.toFixed(1) })));

For the “3+ BPG” cell you should not see hundreds unless your BBGM save truly contains that many. If you still see 500+, check that:
	•	blk and gp exist for seasons (print a few), and
	•	you’re actually passing { type:"seasonBPG", min:3 } for that column.

⸻

After these changes:
	•	The Giannis cell should not show 500+ eligible names for 3+ BPG unless it’s real in your sim.
	•	The modal list will be the true eligible set with non-zero WS for stars.

---

If you want, I can also give you a tiny **unit test snippet** for one cell to sanity-check counts before it hits the UI.