We are introducing a WS-based rarity score per grid cell.
For each cell, take all eligible players, compute career Win Shares (regular season only) = sum(OWS + DWS), sort DESC by WS, then score the guess by reverse percentile index with lower = better:

idx = 0..N-1 (0 = highest WS = most common)
rarityScore = round(100 * idx / (N - 1))   // 0 = most common, 100 = rarest


Implement:

utils/rarityWS.ts – helpers (career WS, compute rarity maps, color function)

cell pipeline – compute/cache rarity maps per cell from the existing eligible list

UI – show a color-coded rarity chip on each correct tile

UI – a Rarity Score section directly under the grid that sums/averages user’s scores (lower = better) for correct guesses only

1) Create src/utils/rarityWS.ts
// src/utils/rarityWS.ts
export type LeaguePlayer = any; // your player shape from league JSON

/** Regular-season career Win Shares = sum(ows + dws) */
export function careerWS_RS(player: LeaguePlayer): number {
  const stats = (player.stats ?? []).filter((s: any) => !s?.playoffs); // treats 0/false/undefined as RS
  let ows = 0, dws = 0;
  for (const s of stats) {
    ows += Number(s?.ows ?? 0);
    dws += Number(s?.dws ?? 0);
  }
  const ws = ows + dws;
  return Number.isFinite(ws) ? ws : 0;
}

/**
 * Build rarity maps for a cell using WS.
 * Sort DESC by WS (highest first = most common).
 * rarityScore = round(100 * idx / (N - 1))  // 0 best/common, 100 rarest/deep cut
 * rank = 1-based position in DESC list (1 = most common)
 */
export function computeCellRarityByWS(eligiblePlayers: LeaguePlayer[]) {
  const arr = eligiblePlayers.map(p => ({ pid: p.pid, ws: careerWS_RS(p) }));
  // stable sort: by ws desc, then pid asc
  arr.sort((a, b) => (b.ws - a.ws) || (a.pid - b.pid));

  const N = arr.length;
  const rarityMap = new Map<number, number>();
  const rankMap = new Map<number, number>();
  const wsMap = new Map<number, number>();

  if (N === 0) return { rarityMap, rankMap, wsMap, eligibleCount: 0, ordered: [] };
  if (N === 1) {
    const only = arr[0];
    rarityMap.set(only.pid, 50); // neutral when only one option
    rankMap.set(only.pid, 1);
    wsMap.set(only.pid, only.ws);
    return { rarityMap, rankMap, wsMap, eligibleCount: 1, ordered: arr };
  }

  arr.forEach((row, idx) => {
    const rarity = Math.round(100 * (idx / (N - 1))); // 0..100 (lower = more “common”)
    rarityMap.set(row.pid, rarity);
    rankMap.set(row.pid, idx + 1); // 1..N
    wsMap.set(row.pid, row.ws);
  });

  return { rarityMap, rankMap, wsMap, eligibleCount: N, ordered: arr };
}

/** Chip color based on score: lower (better/common) = green, higher (rarer) = violet/red */
export function rarityColor(score: number) {
  // 0 → green, 50 → amber, 100 → magenta
  const clamp = (n: number, a: number, b: number) => Math.max(a, Math.min(b, n));
  const hue = clamp(120 - score * 1.2, -40, 300); // 120≈green → down to magenta-ish
  return `hsl(${hue}deg 80% 45%)`;
}

export function rarityBucket(score: number): "Common"|"Uncommon"|"Notable"|"Rare"|"Ultra-rare" {
  if (score >= 80) return "Ultra-rare";
  if (score >= 60) return "Rare";
  if (score >= 40) return "Notable";
  if (score >= 20) return "Uncommon";
  return "Common";
}

2) Compute rarity maps per cell (from your existing eligible list)

You already build “Top Answers” by WS for each cell. Reuse that same eligiblePlayers list here.

Create src/logic/cellRarityByWS.ts:

// src/logic/cellRarityByWS.ts
import { computeCellRarityByWS } from "../utils/rarityWS";

// Optionally add a cache Map<cellKey, { rarityMap, rankMap, wsMap, eligibleCount }>
const cache = new Map<string, any>();

export function buildCellRarityMaps(cellKey: string, eligiblePlayers: any[]) {
  if (cache.has(cellKey)) return cache.get(cellKey);
  const maps = computeCellRarityByWS(eligiblePlayers);
  cache.set(cellKey, maps);
  return maps;
}

// If grids can change during play, export a way to clear just that cellKey.
export function resetCellRarity(cellKey: string) {
  cache.delete(cellKey);
}

3) Hook into the guess flow

When the user chooses a correct player for a cell:

Resolve the cell’s eligiblePlayers

Call buildCellRarityMaps(cellKey, eligiblePlayers)

Read rarity/ rank/ ws and store alongside the cell’s guess

In your guess handler (wherever you mark a correct guess), add something like:

import { buildCellRarityMaps } from "../logic/cellRarityByWS";

function onCorrectGuess(cellKey: string, guessedPlayer: any, eligiblePlayers: any[]) {
  const { rarityMap, rankMap, wsMap, eligibleCount } = buildCellRarityMaps(cellKey, eligiblePlayers);
  const pid = guessedPlayer.pid;
  const rarity = rarityMap.get(pid);
  const rank = rankMap.get(pid);
  const ws = wsMap.get(pid);

  // Attach to your cell state
  updateCell(cellKey, {
    isCorrect: true,
    pid,
    rarity,        // 0..100 (lower = better)
    rarityRank: rank,
    eligibleCount,
    careerWS: ws,
  });

  // Also push to a game/session tracker so we can summarize under the grid
  addRaritySample({ cellKey, pid, rarity, correct: true });
}

4) Tile UI: add a rarity chip (correct guesses only)

In your grid cell component:

// in GridCell.tsx
import { rarityColor, rarityBucket } from "../utils/rarityWS";

{isCorrect && typeof rarity === "number" && (
  <div
    className="rarity-chip"
    title={`Rarity ${rarity} (${rarityBucket(rarity)}) • Rank ${rarityRank} of ${eligibleCount}`}
    style={{
      position: "absolute",
      right: 8, bottom: 8,
      padding: "2px 8px",
      borderRadius: 999,
      fontSize: 12,
      fontWeight: 700,
      background: rarityColor(rarity),
      color: "black",
      boxShadow: "0 0 0 2px rgba(0,0,0,.35)",
    }}
  >
    {rarity}
  </div>
)}


Keep your main tile background green/red for correct/incorrect. The chip is just an overlay showing how good that correct pick was (lower is better).

5) Rarity Score panel under the grid (lower = better)

Create src/components/RaritySummaryUnderGrid.tsx and render it directly below the grid.

// src/components/RaritySummaryUnderGrid.tsx
type Sample = { cellKey: string; pid: number; rarity: number; correct: boolean };

export default function RaritySummaryUnderGrid({ samples }: { samples: Sample[] }) {
  const vals = samples.filter(s => s.correct && typeof s.rarity === "number").map(s => s.rarity as number);
  const total = vals.reduce((a,b)=>a+b, 0);
  const avg = vals.length ? Math.round((total/vals.length)*10)/10 : 0;
  const best = vals.length ? Math.min(...vals) : 0;  // best = lowest score
  const worst = vals.length ? Math.max(...vals) : 0;

  return (
    <div style={{
      marginTop: 12,
      padding: 12,
      borderRadius: 12,
      background: "rgba(255,255,255,0.05)",
      display: "grid",
      gridTemplateColumns: "1fr 1fr 1fr 1fr",
      gap: 8
    }}>
      <Stat label="Rarity Score (total)" value={total} hint="Lower = better" />
      <Stat label="Average" value={avg} hint="" />
      <Stat label="Best pick" value={best} hint="lowest rarity" />
      <Stat label="Most common" value={worst} hint="highest rarity" />
    </div>
  );
}

function Stat({ label, value, hint }:{label:string; value:number|string; hint?:string}) {
  return (
    <div>
      <div style={{opacity:.7, fontSize:12}}>{label}</div>
      <div style={{fontWeight:800, fontSize:18}}>{value}</div>
      {hint ? <div style={{opacity:.55, fontSize:11}}>{hint}</div> : null}
    </div>
  );
}


Mount it under the grid (where you render the grid component):

<RaritySummaryUnderGrid samples={raritySamplesFromState} />


You’ll maintain raritySamplesFromState by pushing from your guess handler (see step 3).

6) Player modal (optional text)

In the player modal under stats, add:

Rarity score: {rarity} (Rank {rarityRank} of {eligibleCount})
Career WS (RS): {careerWS.toFixed(1)}

7) Edge cases / tests

If eligiblePlayers.length <= 1 → score 50, rank 1.

Confirm that your Top Answers (by WS) match the rank order used for rarity.

Test one cell:

Pick the top WS player → score 0, rank 1.

Pick the lowest WS player → score 100, rank N.

Confirm regular-season only (filter !s.playoffs) is applied consistently.

After implementing, please run a grid and verify the chip shows different scores, and the Rarity Score (total) under the grid updates after each correct guess.