Goal: Rarity is broken (everyone shows 100 and the same rank). Please replace our rarity pipeline with the exact code below and wire it into the cell evaluation. This fixes:
â€¢ wrong/constant prominence (NaN/0 from bad data)
â€¢ min==max normalization bugs
â€¢ incorrect rank mapping (same rank for everyone)
â€¢ playoff leakage and string/number coercion issues

Then show the rarity chip + rank correctly on correct guesses, and update the modal.

1) Replace server/utils/rarity.ts (or src/utils/rarity.ts) with this
// utils/rarity.ts
export type PlayerAwards = {
  champ?: number; allStar?: number; allStarMvp?: number; mvp?: number;
  roy?: number; smoy?: number; dpoy?: number; mip?: number;
  finalsMvp?: number; sfmvp?: number;
  allLeague1?: number; allLeague2?: number; allLeague3?: number;
  allDefensive1?: number; allDefensive2?: number; allDefensive3?: number;
  allRookie?: number;
};

export type PlayerCareer = {
  pid: number;
  numSeasons: number;
  gp: number;
  min: number;
  vorp: number;
  ows: number;
  dws: number;
  per?: number;
  obpm?: number;
  dbpm?: number;
  pm100?: number;
  onOff100?: number;
  awards: PlayerAwards;
};

const W_ACC = {
  mvp: 40, finalsMvp: 25, allLeague1: 12, allLeague2: 8, allLeague3: 6,
  allDefensive1: 6, allDefensive2: 4, allDefensive3: 3,
  allStar: 6, allStarMvp: 5, dpoy: 15, roy: 8, smoy: 8, mip: 6,
  sfmvp: 8, allRookie: 2, champ: 6,
} as const;

const clamp01 = (x: number) => Math.max(0, Math.min(1, x));
const minutesFactor = (mins: number) => clamp01(Math.log1p(Math.max(0, mins)) / Math.log1p(30000));
const reliability = (gp: number, seasons: number) => clamp01(0.6*(gp/246) + 0.4*(seasons/5));
const careerValue = (vorp: number, ows: number, dws: number) => 0.6*Math.max(0, vorp) + 0.4*(ows + dws);

function safeNum(n: any, fallback = 0) {
  const v = typeof n === "string" ? Number(n) : n;
  return Number.isFinite(v) ? v : fallback;
}

function mapAwardType(raw: string): keyof PlayerAwards | undefined {
  // Normalize league award strings into our keys
  const s = raw.toLowerCase();
  if (s.includes("mvp") && !s.includes("all-star")) return "mvp";              // season MVP
  if (s.includes("finals mvp") || s === "fmvp") return "finalsMvp";
  if (s.includes("conference finals mvp") || s === "sfmvp") return "sfmvp";
  if (s.includes("all-star mvp")) return "allStarMvp";
  if (s === "all-star" || s.includes("all star")) return "allStar";
  if (s.includes("defensive player of the year")) return "dpoy";
  if (s.includes("rookie of the year")) return "roy";
  if (s.includes("sixth man")) return "smoy";
  if (s.includes("most improved")) return "mip";
  if (s.includes("champ")) return "champ";
  if (s.includes("all-rookie")) return "allRookie";
  if (s.includes("all-defensive 1")) return "allDefensive1";
  if (s.includes("all-defensive 2")) return "allDefensive2";
  if (s.includes("all-defensive 3")) return "allDefensive3";
  if (s.includes("all-nba 1") || s.includes("all-league 1")) return "allLeague1";
  if (s.includes("all-nba 2") || s.includes("all-league 2")) return "allLeague2";
  if (s.includes("all-nba 3") || s.includes("all-league 3")) return "allLeague3";
  return undefined;
}

function accoladesScore(a: PlayerAwards): number {
  let s = 0;
  (Object.keys(W_ACC) as (keyof typeof W_ACC)[]).forEach(k => { s += (a[k] ?? 0) * W_ACC[k]; });
  return s;
}

function rateTalent(per?: number, obpm?: number, dbpm?: number, pm100?: number, onOff100?: number) {
  const perTerm = per != null ? Math.max(0, per - 15) : 0;
  const bpmTerm = (obpm ?? 0) + (dbpm ?? 0);
  const onoff = ((pm100 ?? 0) + (onOff100 ?? 0)) / 2;
  return 0.5*perTerm + 0.4*bpmTerm + 0.1*onoff;
}

export function prominence(p: PlayerCareer): number {
  const A = accoladesScore(p.awards);
  const CV = careerValue(safeNum(p.vorp), safeNum(p.ows), safeNum(p.dws)) * minutesFactor(safeNum(p.min));
  const R  = reliability(safeNum(p.gp), safeNum(p.numSeasons));
  const RT = rateTalent(safeNum(p.per, 15), safeNum(p.obpm), safeNum(p.dbpm), safeNum(p.pm100), safeNum(p.onOff100)) * R;
  const L  = 0.5 * Math.log1p(safeNum(p.gp)) + 0.5 * safeNum(p.numSeasons);
  const prom = 0.45*A + 0.25*CV + 0.20*RT + 0.10*L;
  // Guard: NaN or -Inf â†’ 0
  return Number.isFinite(prom) ? prom : 0;
}

/** Normalize within a cell. 0=most common, 100=rarest. */
export function rarityScoresForEligible(players: PlayerCareer[]) {
  const arr = players.map(p => ({ pid: p.pid, prom: prominence(p) }));
  const min = Math.min(...arr.map(a => a.prom));
  const max = Math.max(...arr.map(a => a.prom));
  let rng = max - min;
  if (!Number.isFinite(min) || !Number.isFinite(max)) rng = 0;

  return arr.map(a => {
    let rarity: number;
    if (rng <= 1e-9) {
      // everyone tied â†’ middle value, not 100
      rarity = 50;
    } else {
      rarity = Math.round(100 * (1 - (a.prom - min) / rng));
    }
    return { pid: a.pid, prom: a.prom, rarity };
  });
}

/** Build PlayerAwards map from raw awards array (league-specific strings). */
export function reduceAwards(rawAwards: Array<{ type: string }>): PlayerAwards {
  const acc: PlayerAwards = {};
  for (const a of rawAwards ?? []) {
    const key = mapAwardType(a.type);
    if (key) (acc as any)[key] = ((acc as any)[key] ?? 0) + 1;
  }
  return acc;
}

2) Replace the adapter that builds PlayerCareer (regular season only)
// utils/careerAdapter.ts
import type { PlayerCareer } from "./rarity";
import { reduceAwards } from "./rarity";

export function toPlayerCareerRS(player: any): PlayerCareer {
  const rs = (player.stats ?? []).filter((s: any) => s && s.playoffs === false);

  const seasons = new Set(rs.map((s: any) => s.season)).size;
  const sum = (k: string) => rs.reduce((t: number, s: any) => t + (Number(s?.[k]) || 0), 0);
  const avg = (k: string, fallback = 0) => {
    const vals = rs.map((s: any) => Number(s?.[k])).filter((v) => Number.isFinite(v));
    return vals.length ? vals.reduce((a, b) => a + b, 0) / vals.length : fallback;
  };

  return {
    pid: player.pid,
    numSeasons: seasons,
    gp: sum("gp"),
    min: sum("min"),
    vorp: sum("vorp"),
    ows: sum("ows"),
    dws: sum("dws"),
    per: avg("per", 15),
    obpm: avg("obpm", 0),
    dbpm: avg("dbpm", 0),
    pm100: avg("pm100", 0),
    onOff100: avg("onOff100", 0),
    awards: reduceAwards(player.awards ?? []),
  };
}

3) Fix per-cell normalization + rank mapping
// logic/cellRarity.ts
import { rarityScoresForEligible } from "../utils/rarity";
import { toPlayerCareerRS } from "../utils/careerAdapter";

export function computeCellRarity(eligiblePlayers: any[]) {
  const careers = eligiblePlayers.map(toPlayerCareerRS);
  const scores = rarityScoresForEligible(careers);

  // Build rarity + rank maps (rank 1 = most common = lowest rarity)
  const byRarityAsc = [...scores].sort((a, b) => a.rarity - b.rarity);
  const rankMap = new Map<number, number>();
  byRarityAsc.forEach((s, i) => rankMap.set(s.pid, i + 1)); // 1-based rank

  const rarityMap = new Map<number, number>();
  scores.forEach(s => rarityMap.set(s.pid, s.rarity));

  return { rarityMap, rankMap, eligibleCount: scores.length };
}


Important UI fix: donâ€™t compute rank using findIndex on a different array (that caused the constant â€œrank 6â€). Always compute a dedicated rank map from the sorted results, then read rankMap.get(pid).

4) Wire into the grid cell + modal

When a cell becomes visible or on first guess, call computeCellRarity(eligiblePlayers) once and cache it per cell key (rowId|colId).

On a correct guess, read:

rarity = rarityMap.get(guessedPid)

rank = rankMap.get(guessedPid)

eligibleCount

Show the chip in the tile and the numbers in the modal.

5) Add guards + debug to catch regressions

If rarity === undefined, log the cell key + player PID and donâ€™t show the chip.

If eligibleCount < 2, set rarity = 50 and rank = 1 of N.

Log once per cell: min/max/prominence range and how many ties there are.

Example:

if (process.env.NODE_ENV !== "production") {
  const proms = [...rarityMap.entries()].map(([pid]) => scores.find(s => s.pid === pid)!.prom);
  const min = Math.min(...proms), max = Math.max(...proms);
  console.debug(`[rarity] cell=${cellKey} eligible=${eligibleCount} promRange=[${min.toFixed(2)}, ${max.toFixed(2)}]`);
}

ğŸ¨ Color & display (keep yours; ensure values vary)

Tile stays green/red for correctness.

Rarity chip uses your function or a fixed palette:

0â€“19 teal, 20â€“39 green, 40â€“59 amber, 60â€“79 orange, 80â€“100 violet.

ğŸ§ª What to test (tell the bot)

Pick an obvious answer (e.g., LeBron in a Cavs+5k AST cell) â†’ rarity should be near 0 and rank â‰ˆ 1.

Pick a deep cut for the same cell â†’ rarity should be much higher and rank higher (e.g., 40th of 120).

Open the modal â†’ â€œRarity â€¢ Rank X of N eligibleâ€ must match the chip.

Try a cell with very few eligibles â†’ no crash; rarity ~50; rank correct.

Confirm that regular season only is used (no playoff rows in sums).